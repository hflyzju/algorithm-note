# æ€»ç»“

## é¢ç­‹æ€»ç»“
|é¢è¯•id|  é¢è¯•ç±»å‹ | æ—¶é—´  | é¢˜ç›® | ç±»å‹ | éš¾åº¦ | é¢˜è§£ |
| ---- |  ----  | ----  | --- | --- | --- | --- |
| 1.MLEä¸€æ¡é¾™æ–°é²œé¢ç» |  åº—é¢-é¢˜ç›®1  |2022.07| 791ï¼šCustom Sort String: è®©sæŒ‰orderæ’åºè¾“å‡º | å“ˆå¸Œ+æ’åº | ä¸­ç­‰ | å…ˆç»Ÿè®¡éœ€è¦æ’åºçš„å­—ç¬¦ä¸²ï¼Œç„¶åæŒ‰orderè¾“å‡ºï¼Œæ³¨æ„ä¸å­˜åœ¨orderä¸­çš„å­—ç¬¦ |
| 1.MLEä¸€æ¡é¾™æ–°é²œé¢ç» |  åº—é¢-é¢˜ç›®2  |2022.07| 560. Subarray Sum Equals Kï¼šå­åºåˆ—å’Œä¸ºkçš„ä¸ªæ•°ï¼Œæ³¨æ„æ•°å­—å¯èƒ½ä½è´Ÿæ•°  | å‰ç¼€å’Œ | ä¸­ç­‰åéš¾ |ç»Ÿè®¡æ¯ä¸ªå‰ç¼€å’Œå‡ºç°çš„æ¬¡æ•°ï¼Œç»Ÿè®¡cur_pre_sum - targetçš„æ¬¡æ•°å³å¯ï¼Œæ³¨æ„pre_sum_cnt[0]=1, è§£å†³[1,1] k=2 => 1è¿™ç§é—®é¢˜ |
| 1.MLEä¸€æ¡é¾™æ–°é²œé¢ç» |  on-site1-Coding 1  |2022.07| 670. Maximum Swapï¼šè¿”å›åªå¯ä»¥swapä¸€æ¬¡åæœ€å¤§çš„æ•°| æ•°ç»„ | ä¸­ç­‰ |ä»åå¾€å‰éå†å¹¶è®°å½•æœ€å¤§å€¼ï¼Œå¯¹æ¯ä¸ªä½ç½®ï¼Œä¸æ›¿æ¢æœ€å¤§å€¼æ›¿æ¢å¯ä»¥å–å¾—è¯¥ä½ç½®swapåçš„æœ€å¤§å€¼ï¼Œä¸æœ€å‰é¢ä¸€ä¸ªä½ç½®swapå¯ä»¥å–å¾—å…¨å±€æœ€å¤§å€¼|
| 1.MLEä¸€æ¡é¾™æ–°é²œé¢ç» |  on-site1-Coding 2  |2022.07| 394. Decode Stringï¼šå°†ä¾‹å¦‚å¤šå±‚åµŒå¥—çš„s=3[a3[c]]è¿›è¡Œè§£ç |æ ˆ| ä¸­ç­‰åéš¾ |æ³¨æ„åªä¼šå‡ºç°k[]çš„å½¢å¼ï¼Œæ‰€ä»¥å˜ç®€å•ä¸€ç‚¹ï¼Œç”¨pre_resè®°å½•ä¹‹å‰ç´¯ç§¯çš„å­—ç¬¦ä¸²ï¼Œcntè®°å½•æ‹¬å·å‰çš„æ•°å­—, resè®°å½•å½“å‰çš„å­—ç¬¦ï¼Œé‡åˆ°]å¯ä»¥æ›´æ–°res=pre_res + cnt * resï¼Œ é‡åˆ°[å¯ä»¥å°†å‰é¢çš„pre_reså’Œæ•°å­—cntå‹å…¥æ ˆ|
| 1.MLEä¸€æ¡é¾™æ–°é²œé¢ç» |  on-site1-Coding 3  |2022.07| 543. diameter of the treeï¼š æ ‘çš„ç›´å¾„|æ ‘|ä¸­ç­‰|åç»­éå†+æ¯æ¬¡ç»Ÿè®¡æ ‘çš„æ·±åº¦+åˆ©ç”¨åç»­éå†è®¡ç®—åŒ…å«å½“å‰èŠ‚ç‚¹çš„ç›´å¾„|
| 2. META ML RSè¿‡ç»åŠtimeline |  åº—é¢-Coding 1  |2022.01| Lowest Common Ancestor of a Binary Treeï¼š ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€å°å…¬å…±ç¥–å…ˆ|æ ‘|ä¸­ç­‰|æ–¹æ³•1: é€’å½’ï¼šå½“å‰èŠ‚ç‚¹çš„è¾“å‡ºå¯ä»¥ç”±å·¦å­©å­æˆ–è€…å³å­©å­èƒ½è¿”å›ç»“æœæ¥å®šï¼Œå¦‚æœå·¦å­©å­æˆ–è€…å³å­©å­éƒ½ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆè¿”å›å½“å‰èŠ‚ç‚¹ã€‚å¦åˆ™è¿”å›ä¸¤è€…ä¹‹ä¸€ã€‚æ–¹æ³•2: æ ˆï¼šè·Ÿè¸ªè·ŸèŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„çš„path(å…ˆåºéå†å…¥æ ˆï¼Œåç»­éå†å‡ºæ ˆå¯)ï¼Œç„¶åæ¯”è¾ƒä¸¤ä¸ªèŠ‚ç‚¹çš„pathï¼Œæ‰¾å‡ºæœ€ä½çš„ancestor|
| 2. META ML RSè¿‡ç»åŠtimeline |  åº—é¢-Coding 2  |2022.01| 523. Continuous Subarray Sumï¼šæ˜¯å¦å­˜åœ¨é•¿åº¦å¤§äº2çš„è¿ç»­å’Œä¸ºkçš„å­æ•°ç»„ |æ•°ç»„+æ•°å­¦|ä¸­ç­‰é€šè¿‡ç‡30%|å‰ç¼€å’Œå¯¹kå–ä½™æ•°ï¼Œå¦‚æœä½™æ•°modç›¸ç­‰ï¼Œé‚£ä¹ˆä»£è¡¨ä¸­é—´çš„é‚£æ®µæ•°ä¸ºkçš„å€æ•°ï¼Œè¦æ³¨æ„[1,1] k=2è¿™ç§æƒ…å†µï¼Œå¯ä»¥å¦pre_mod_index[0]=-1|
| 2. META ML RSè¿‡ç»åŠtimeline |  on-site1-Coding 1  |2022.01| 339. Nested List Weight Sumï¼šå¤šé‡åµŒå¥—æ•°ç»„å’Œ|æ ˆ|ä¸­ç­‰|é€’å½’ï¼šå…ˆåºéå†depth+1ï¼Œåç»­éå†depth-1ï¼Œè¿™æ ·è¾“å‡ºå’Œ|
| 2. META ML RSè¿‡ç»åŠtimeline |  on-site1-Coding 2  |2022.01| 133. Clone Graphï¼šå…‹éš†æ— å‘å›¾|dfsæˆ–è€…bfs|ä¸­ç­‰|ç”¨å­—å…¸è®°å½•æ¯ä¸ªèŠ‚ç‚¹åˆ°å…¶copyèŠ‚ç‚¹çš„æ˜ å°„ï¼Œç„¶åç”¨bfsæ±‚è§£ï¼Œæ¯”è¾ƒæ–¹ä¾¿|
| 2. META ML RSè¿‡ç»åŠtimeline |  on-site1-Coding 3  |2022.01| Basic Calculator II: è®¡ç®—æ— æ‹¬å·çš„åŠ å‡ä¹˜åˆçš„ç»“æœ|æ ˆ or ä¼˜åŒ–ç‰ˆæœ¬|ä¸­ç­‰|1. åªéœ€è¦è®°å½•ans(ä¸Šä¸ªä½ç½®ä¹‹å‰çš„ç»“æœ)ï¼Œpre_val(ä¸Šä¸€ä¸ªä½ç½®ç»“æœ)ï¼Œcur_val(å½“å‰ä½ç½®ç»“æœ)è¿™ä¸‰ä¸ªæ•°ï¼Œå¯ä»¥å°†ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–åˆ°O(1). 2.é‡åˆ°+-*/ç¬¦å·æˆ–è€…åˆ°ç»“æŸä½ç½®å°±è®¡ç®—ç»“æœ|
| 2. META ML RSè¿‡ç»åŠtimeline |  on-site2-Coding 1  |2022.07| 65. Valid Number: æ˜¯å¦ä¸ºæœ‰æ•ˆçš„floatæ•°çš„å­—ç¬¦ä¸²ï¼Œå¯èƒ½åŒ…å«.+-eEç­‰ç¬¦å·| å­—ç¬¦ä¸² | ä¸­ç­‰ |æ³¨æ„å¾ˆå¤šbadcase|
| 2. META ML RSè¿‡ç»åŠtimeline |  on-site2-Coding 1  |2022.07| 670. Maximum Swapï¼šè¿”å›åªå¯ä»¥swapä¸€æ¬¡åæœ€å¤§çš„æ•°| æ•°ç»„ | ä¸­ç­‰ |ä»åå¾€å‰éå†å¹¶è®°å½•æœ€å¤§å€¼ï¼Œå¯¹æ¯ä¸ªä½ç½®ï¼Œä¸æ›¿æ¢æœ€å¤§å€¼æ›¿æ¢å¯ä»¥å–å¾—è¯¥ä½ç½®swapåçš„æœ€å¤§å€¼ï¼Œä¸æœ€å‰é¢ä¸€ä¸ªä½ç½®swapå¯ä»¥å–å¾—å…¨å±€æœ€å¤§å€¼|

## é«˜é¢‘é¢˜æ€»ç»“
|ç±»åˆ«|ç±»å‹|  é¢˜å· | éš¾åº¦  | é¢˜ç›® | é¢˜è§£ | 
| --- | ---- |  ----  | ----  | --- | --- |
|å­—ç¬¦ä¸²| å­—ç¬¦ä¸²-æ‹¬å·åˆ é™¤ |  1249. Minimum Remove to Make Valid Parentheses  | ä¸­ç­‰  | è¾“å…¥æ‹¬å·å’Œè‹±æ–‡å­—æ¯ï¼Œè¿”å›æœ€å°‘åˆ é™¤åvalidçš„å­—ç¬¦ä¸² | 1. åªæœ‰å³è¾¹æ‹¬å·ä¼˜å…ˆåˆ é™¤ã€‚2.å‰©ä½™çš„å·¦è¾¹çš„æ‹¬å·éœ€è¦åˆ é™¤ã€‚ 3. è®°å½•éœ€è¦åˆ é™¤çš„index_setï¼Œè¿”å›ä¸åœ¨index_setä¸­çš„å­—ç¬¦ä¸²å³å¯ã€‚4. å¦‚æœè¦è¿”å›æ‰€æœ‰çš„åˆç†çš„ç»“æœï¼Œé‚£ä¹ˆéœ€è¦ä»å·¦åˆ°å³å…ˆåˆ é™¤å³è¾¹çš„æ‹¬å·ï¼Œå³è¾¹çš„æ‹¬å·åˆ é™¤å®Œäº†ï¼Œæ‰èƒ½åˆ é™¤å‰©ä½™çš„å·¦è¾¹çš„æ‹¬å·ï¼Œå› ä¸ºå…ˆåˆ é™¤å·¦æ‹¬å·ï¼Œä¼šå¯¼è‡´å·¦è¾¹çš„å³æ‹¬å·å¯èƒ½æ›´åŠ æ²¡æ³•åŒ¹é…ã€‚|
|å­—ç¬¦ä¸²| å­—ç¬¦ä¸²å¤„ç† |  67. Add Binary  | ä¸­ç­‰  | å­—ç¬¦ä¸²ç›¸åŠ  | æ³¨æ„æ£€æŸ¥ç»“æŸä½ç½®çš„add|
|å›æº¯| å­—ç¬¦ä¸²-æ‹¬å·åˆ é™¤ |  301. Remove Invalid Parentheses  | å›°éš¾  | å°½å¯èƒ½åˆ é™¤æœ€å°çš„å·¦å³æ‹¬å·æ•°é‡ä½¿å­—ç¬¦ä¸²åŒ¹é…ï¼Œè¿”å›æ‰€æœ‰å¯èƒ½çš„åŒ¹é…çš„ç»“æœã€‚ | 1. å…ˆåˆ†åˆ«ç»Ÿè®¡å·¦å³éœ€è¦åˆ é™¤çš„æ‹¬å·çš„æ•°é‡ï¼Œç„¶åå…ˆåˆ é™¤å³æ‹¬å·ï¼Œå†åˆ é™¤å·¦æ‹¬å·ã€‚2. æ¯”è¾ƒéš¾æƒ³åˆ°çš„æ˜¯ç”¨é€’å½’çš„æ–¹æ³•ä¾æ¬¡åˆ é™¤æ‹¬å·ã€‚ 3. æ³¨æ„startç”¨äºæ ‡è®°å›æº¯ç®—æ³•å½“å‰åˆ é™¤èŠ‚ç‚¹çš„èµ·ç‚¹ä½ç½®ã€‚|
|é€’å½’| å­—ç¬¦ä¸²å¤„ç† |  273. Integer to English Words  | å›°éš¾  | æ•°å­—è½¬è‹±æ–‡ |1. é€’å½’æ€æƒ³è§£å†³1-10ï¼Œ10-20ï¼Œ20-100ï¼Œ100-1000ï¼Œ1000-1000000ï¼Œ 1000000-1000000000çš„è‹±æ–‡å¤„ç†ã€‚2. æ³¨æ„fourï¼Œfortyï¼Œtwentyï¼Œthousandï¼Œmillionï¼Œbillionç­‰å†™æ³•ã€‚|
|åŒæŒ‡é’ˆ| å­—ç¬¦ä¸²-å›æ–‡ä¸²-åŒæŒ‡é’ˆ |  680. Valid Palindrome II  | ä¸­ç­‰  | æœ€å¤šåˆ é™¤ä¸€ä¸ªå­—ç¬¦ï¼Œé—®å­—ç¬¦ä¸²æ˜¯å¦èƒ½ä¸ºå›æ–‡ä¸² | 1. ç¬¬ä¸€ååº”ï¼Œå°è¯•å¯¹æ¯ä¸ªå­—ç¬¦ä¸²æ¥è¿›è¡Œåˆ é™¤ï¼ŒéªŒè¯æ˜¯å¦æ˜¯å›æ–‡ä¸²ï¼Œæˆ–è€…å­—ç¬¦ä¸²æœ¬èº«å°±æ˜¯å›æ–‡ä¸²ï¼Œæ—¶é—´å¤æ‚åº¦O(n**2)çº§åˆ«ã€‚2. ä¼˜åŒ–ï¼šåŒæŒ‡é’ˆï¼Œå…ˆæ‰¾åˆ°éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼Œç„¶ååˆ é™¤å·¦è¾¹æˆ–è€…å³è¾¹ï¼Œæ¥çœ‹æ˜¯å¦æ˜¯å›æ–‡ä¸²ï¼Œæ—¶é—´å¤æ‚åº¦å¯ä»¥ä¼˜åŒ–åˆ°O(n)çº§åˆ«ã€‚|
|åŒæŒ‡é’ˆ| æ•°ç»„ |  [31]Next Permutation  | ä¸­ç­‰  | æ±‚ä¸‹ä¸€ä¸ªæ’åˆ—ï¼ˆæ¯”å½“å‰èŠ‚ç‚¹å¤§ï¼‰ | 1. ä»åå¾€å‰ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªé€†åºçš„æ•°å­—ï¼Œé€†åºä»£è¡¨ä»åé¢swapå¯ä»¥æ‰¾åˆ°ä¸€ä¸ªæ›´å¤§çš„æ•°ã€‚ 2. swapåï¼Œå¯¹åé¢çš„æ•°å­—åˆ©ç”¨åŒæŒ‡é’ˆå€’åºæ’åˆ—ï¼Œå³ä¸ºä¸‹ä¸€ä¸ªæœ€å¤§çš„æ•°å­—ã€‚|
|æ’åº| æ’åº |  953. Verifying an Alien Dictionary  | ä¸­ç­‰  | éªŒè¯wordsæ˜¯å¦æŒ‰ç…§å¤–æ˜Ÿäººçš„å­—æ¯è¡¨è¿›è¡Œæ’åº | 1. å…ˆç»Ÿè®¡æ¯ä¸ªå¤–æ˜Ÿäººçš„å­—æ¯çš„é¡ºåºindexï¼Œç„¶åä»å·¦åˆ°å³éªŒè¯wordsä¸­æ¯ä¸ªå­—ç¬¦ä¸å‰ä¸€ä¸ªå­—ç¬¦æ˜¯å¦æ˜¯æ’å¥½åºçš„ã€‚|
|æ’åº| æ•°ç»„æ’åº |  [56]Merge Intervals  | ä¸­ç­‰  | åˆå¹¶é—´éš” | å…ˆæ’åºååˆå¹¶|
|æ•°ç»„| ç±»ä¼¼å‰ç¼€å’Œ |  [238]Product of Array Except Self  | ä¸­ç­‰  | è®¡ç®—é™¤è‡ªèº«å¤–çš„product | åˆ†åˆ«è®°å½•å·¦è¾¹å’Œå³è¾¹çš„productï¼Œç„¶åè¾“å‡ºï¼Œæ—¶é—´å¤æ‚åº¦å¯ä»¥ä¼˜åŒ–åˆ°O(n)|
|æ•°ç»„| æ•°ç»„ |  [1762]Buildings With an Ocean View  | ä¸­ç­‰  | æœ€åä¸€ä¸ªæ˜¯æµ·ï¼Œå¦‚æœå»ºç­‘æ¯”åé¢çš„é«˜å°±å¯ä»¥çœ‹åˆ°æµ·ï¼Œè¾“å‡ºæ‰€æœ‰èƒ½çœ‹åˆ°æµ·çš„index | ç›´æ¥å€’åºæœç´¢å°±å¯ä»¥|
|æ ‘| bfsï¼Œdfs|  314. Binary Tree Vertical Order Traversal  | ä¸­ç­‰  | äºŒè¿›åˆ¶æ ‘çš„å‚ç›´æœç´¢ | 1. bfsç›´æ¥æœç´¢ï¼Œç„¶årootçš„åæ ‡ä¸º0ï¼Œå·¦è¾¹-1ï¼Œå³è¾¹+1ï¼Œç„¶åç”¨loc_to_vallistè®°å½•æ¯ä¸ªlocçš„åæ ‡ï¼ŒåŒæ—¶è®°å½•min_locå’Œmax_locæœ€ç»ˆç›´æ¥è¾“å‡ºå³å¯ã€‚|
|æ ‘| æ ‘çš„æœç´¢ |  [938]Range Sum of BST  | ä¸­ç­‰  | ç»™å®šä¸€ä¸ªèŒƒå›´å’Œä¸€é¢—BSTæ ‘ï¼Œé—®åœ¨è¿™ä¸ªèŒƒå›´å†…çš„æ•°å­—çš„å’Œ | ç›´æ¥æ ‘çš„äºŒåˆ†æœç´¢å³å¯|
|topkå¿«æ’| æ•°ç»„æ’åº |  [215]Kth Largest Element in an Array  | ä¸­ç­‰  | æ‰¾åˆ°ç¬¬topkå¤§çš„æ ‘ | å¿«æ’+é€’å½’æ€æƒ³ï¼Œæ‰¾å‰kå¤§æˆ–è€…ç¬¬kå¤§éƒ½å¯ä»¥åš |
|æ ‘| æ ‘çš„æœç´¢ |  [199]Binary Tree Right Side View  | ä¸­ç­‰  | ä»å³è¾¹çœ‹èƒ½çœ‹åˆ°çš„æ ‘çš„æ•°å­— | è®°å½•æ¯ä¸€å±‚æ˜¯å¦visitedè¿‡ï¼Œå…ˆå³è¾¹ï¼Œå†å·¦è¾¹é€’å½’éå†ï¼Œè¿™æ ·å°±å¯ä»¥æ”¶é›†æ¯ä¸€å±‚ç¬¬ä¸€æ¬¡è®¿é—®çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°±æ˜¯ç»“æœ|
|æ ‘| åç»­ä¾¿åˆ©æœç´¢ |  236 Lowest Common Ancestor of a Binary Tree  | ä¸­ç­‰  | äºŒå‰æ ‘æœ€è¿‘çš„çˆ¶èŠ‚ç‚¹ | 1. é€’å½’å®ç°ï¼Œå¯¹äºå·¦è¾¹æˆ–è€…å³è¾¹éƒ½èƒ½æ‰¾åˆ°qæˆ–è€…pï¼Œé‚£ä¹ˆrootå°±æ˜¯ç»“æœï¼Œå¦åˆ™å¯ä»¥é€’å½’æ£€æŸ¥å·¦è¾¹æˆ–è€…å³è¾¹ã€‚ 2. å¯¹äºroot=qæˆ–è€…root=pæˆ–è€…rootä¸ºNoneï¼Œå¯ä»¥ç›´æ¥è¿”å›ç»“æœã€‚|
|è®¾è®¡é¢˜| å­—ç¬¦ä¸²å¤„ç† |  [1570]Dot Product of Two Sparse Vectors  | ä¸­ç­‰  | ç¨€ç–çŸ©é˜µç‚¹ä¹˜ | 1. å‚¨å­˜çš„æ—¶å€™ï¼Œåªè®°å½•ä¸ä¸º0çš„indexå’Œvalã€‚ 2.è®¡ç®—ç‚¹ä¹˜çš„æ—¶å€™ï¼Œå¯ä»¥ç”¨åŒæŒ‡é’ˆçš„æ€æƒ³æ¥matchå¹¶è®¡ç®—ç‚¹ä¹˜å’Œã€‚|
|è®¾è®¡é¢˜| æ•°ç»„ |  528. Random Pick with Weight  | ä¸­ç­‰  | æŒ‰ç»™å®šçš„æƒé‡wï¼Œéšæœºé€‰æ‹©æ•°æ® | 1. è®¡ç®—æƒé‡çš„ç´¯ç§¯æ¦‚ç‡å’Œï¼Œç„¶ååˆ©ç”¨random.ramdom()ç”Ÿæˆä¸€ä¸ªéšæœºçš„æ•°ã€‚2. åˆ©ç”¨äºŒåˆ†æ‰¾åˆ°æ¦‚ç‡åœ¨ç´¯ç§¯æ¦‚ç‡å’Œä¸­çš„åŒºåŸŸä½ç½®ï¼Œæ‰¾åˆ°åå³å¯è¿”å›ç»“æœã€‚|
|è®¾è®¡é¢˜| ä¸­åºéå†éé€’å½’å†™æ³•æ”¹ç¼– |  173. Binary Search Tree Iteratory  | ä¸­ç­‰  | è®¾è®¡ä¸ªç±»ï¼Œå¯ä»¥å®ç°BSTçš„nextï¼ŒhasNextçš„å‡½æ•° | 1. ä¸­åºéå†éé€’å½’æ–¹æ³•ç”¨æ ˆå®ç°ï¼Œé¦–å…ˆä¸€ç›´å¾€å·¦å‹å…¥æ ˆï¼Œç„¶åå¼¹å‡ºï¼Œç„¶åæ”¹æˆå³èŠ‚ç‚¹ç»§ç»­å‹å…¥ã€‚2. inité˜¶æ®µæ‰§è¡Œå¾€å·¦å‹æ ˆä¸èµ°ï¼ŒhasNextæ£€æŸ¥æ ˆæ˜¯å¦ä¸ºç©ºï¼Œnextå¼¹å‡ºï¼Œå¹¶åˆ‡æ¢æˆå³èŠ‚ç‚¹ã€‚|
|ä½è¿ç®—| æ•°å­¦ |  29 Divide Two Integers  | ä¸­ç­‰  | ä¸ç”¨ä¹˜é™¤æ³•å®ç°é™¤æ³• | 1. ä¸€ç›´ç´¯åŠ å¯ä»¥å®ç°ï¼Œä½†æ˜¯è€—æ—¶æ¯”è¾ƒé•¿ï¼Œä¾‹å¦‚2000/2è¦ç´¯åŠ 1000æ¬¡ï¼Œå¯ä»¥è€ƒè™‘ç´¯åŠ (2,1)ï¼Œç¿»å€å(4,2)ï¼Œç¿»å€å(8,4)è¿™ç§æ–¹å¼æ¥å®ç°ã€‚2. åˆå§‹åŒ–base=2ï¼Œcnt=1ï¼Œæ¯æ¬¡baseå’Œcntç¿»å€ï¼ŒçŸ¥é“a - b < bå°±ä¸ç¿»å€äº†ï¼Œè®°å½•æ­¤æ—¶çš„cntï¼Œç„¶åç”¨a -= baseï¼Œç»§ç»­é‡å¤2ï¼Œç›´åˆ°a < bã€‚ 3.æ³¨æ„è¾“å‡ºçš„èŒƒå›´ä¸ºintçš„æœ€å¤§å€¼å’Œæœ€å°å€¼ã€‚|
|è®¾è®¡é¢˜| æ ‘çš„åºåˆ—åŒ– |  297 Serialize and Deserialize Binary Tree  | å›°éš¾  | å°†ä¸€ä¸ªäºŒè¿›åˆ¶æ ‘åºåˆ—åŒ–å’Œéåºåˆ—åŒ– | 1. å¯ä»¥åˆ©ç”¨bfsåºåˆ—åŒ–ï¼Œæ³¨æ„valä¸ºè´Ÿæ•°çš„æ—¶å€™ï¼Œæœ‰ä¸ªè´Ÿå·ï¼Œæ‰€ä»¥åºåˆ—åŒ–çš„æ—¶å€™ï¼Œæœ€å¥½åŠ ä¸€ä¸ªåˆ†éš”ç¬¦ã€‚2. ååºåˆ—åŒ–çš„æ—¶å€™ï¼Œè¿˜æ˜¯ç”¨bfsæ€æƒ³ï¼Œç”¨iè®°å½•ç”¨åˆ°é‚£ä¸ªåºåˆ—åŒ–çš„æ•°æ®äº†ï¼Œæ¯ä¸ªæ•°æ®ï¼Œæœ‰ä¸¤ä¸ªå­©å­ï¼Œéœ€è¦æ¶ˆè€—2ä¸ªå­©å­æ¥å®ç°ï¼Œå¯¹äºéç©ºçš„èŠ‚ç‚¹ï¼Œå¯ä»¥ç›´æ¥åŠ åˆ°dequeé‡Œé¢å»ï¼Œç»§ç»­è¿›è¡Œbfsã€‚|
|äºŒåˆ†| äºŒåˆ†æ³• |  278 First Bad Version  | ä¸­ç­‰  | å·²çŸ¥ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚å¦‚ä½•æ‰¾åˆ°ç¬¬ä¸€é¢bad version | cand+äºŒåˆ†æ€æƒ³è§£å†³é—®é¢˜ã€‚|
|ä¸Šä¸‹è½¦é—®é¢˜| æ•°ç»„ |  253 Meeting Rooms II  | ä¸­ç­‰  | å·²çŸ¥æ¯ä¸ªä¼šè®®çš„å¼€å§‹ç»“æŸæ—¶é—´ï¼Œé—®æœ€å°‘éœ€è¦å¤šå°‘ä¸ªä¼šè®®å®¤ã€‚ | è½¬åŒ–æˆæ¯ä¸ªä¼šè®®å¼€å§‹æ—¶+1ï¼Œæ¯ä¸ªä¼šè®®ç»“æŸæ—¶-1ï¼Œå¤„ç†çš„æ—¶å€™éœ€è¦ä»å°åˆ°å¤§æ’åºï¼Œè¿™æ ·å¯ä»¥è®°å½•æ¯ä¸ªæ—¶é—´ç»“æŸæ—¶å€™çš„äººå‘˜çš„æ•°é‡ï¼Œè¿”å›æœ€å¤§çš„å³å¯ã€‚|
|è®¡æ•°| æ•°å­¦ |  621. Task Scheduler  | ä¸­ç­‰  | ä¸€å †å­—æ¯ç”¨cpuæ¥å¤„ç†ï¼Œæ¯ä¸ªå­—æ¯éœ€è¦é—´éš”sepæ‰èƒ½é‡æ–°å‡ºç°ï¼Œæ¯ä¸ªæ—¶åˆ»å¯ä»¥ç­‰ä¸€ä¸‹ï¼Œé—®æœ€ä½éœ€è¦å¤šå°‘cpuæ—¶é—´ | äºŒç»´å›¾ï¼Œå¯¹äºæœ€å¤§çš„é¢‘æ¬¡çš„å­—æ¯ï¼Œä¹˜ä»¥é—´éš”ï¼Œå°±å¯èƒ½æ˜¯ç»“æœï¼Œå› ä¸ºå¯èƒ½å…¶ä»–çš„å­—ç¬¦æ¯”è¾ƒå¤šï¼Œä½†æ˜¯å‡ºç°çš„é¢‘æ¬¡è¾ƒä½ï¼Œæ‰€ä»¥éœ€è¦å–ä¸¤è€…æœ€å¤§å€¼ï¼šmax((max_freq_num - 1) * (sep + 1) + num_of_max_freq, len(s))|
|å­—ç¬¦ä¸²| å­—ç¬¦ä¸²å¤„ç† |  67. Add Binary  | ä¸­ç­‰  | å­—ç¬¦ä¸²ç›¸åŠ  | æ³¨æ„æ£€æŸ¥ç»“æŸä½ç½®çš„add|
|å­—ç¬¦ä¸²| å­—ç¬¦ä¸²å¤„ç† |  67. Add Binary  | ä¸­ç­‰  | å­—ç¬¦ä¸²ç›¸åŠ  | æ³¨æ„æ£€æŸ¥ç»“æŸä½ç½®çš„add|
|å­—ç¬¦ä¸²| å­—ç¬¦ä¸²å¤„ç† |  67. Add Binary  | ä¸­ç­‰  | å­—ç¬¦ä¸²ç›¸åŠ  | æ³¨æ„æ£€æŸ¥ç»“æŸä½ç½®çš„add|
|å­—ç¬¦ä¸²| å­—ç¬¦ä¸²å¤„ç† |  67. Add Binary  | ä¸­ç­‰  | å­—ç¬¦ä¸²ç›¸åŠ  | æ³¨æ„æ£€æŸ¥ç»“æŸä½ç½®çš„add|
|å­—ç¬¦ä¸²| å­—ç¬¦ä¸²å¤„ç† |  67. Add Binary  | ä¸­ç­‰  | å­—ç¬¦ä¸²ç›¸åŠ  | æ³¨æ„æ£€æŸ¥ç»“æŸä½ç½®çš„add|







# [é¢è¯•ç»éªŒ] FB MLEä¸€æ¡é¾™æ–°é²œé¢ç»
https://www.1point3acres.com/bbs/thread-650769-1-1.html

## åº—é¢

### é¢˜ç›®1ï¼š791. Custom Sort String

```
791. Custom Sort String
You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.

Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.

Return any permutation of s that satisfies this property.

Example 1:

Input: order = "cba", s = "abcd"
Output: "cbad"
Explanation: 
"a", "b", "c" appear in order, so the order of "a", "b", "c" should be "c", "b", and "a". 
Since "d" does not appear in order, it can be at any position in the returned string. "dcba", "cdba", "cbda" are also valid outputs.
Example 2:

Input: order = "cbafg", s = "abcd"
Output: "cbad"
```

```python
class Solution(object):
    def customSortString(self, order, s):
        """
        :type order: str
        :type s: str
        :rtype: str
        """
        letter_to_freq = defaultdict(int)
        for letter in s:
            letter_to_freq[letter] += 1
        res = []
        order_letter_set = set()
        for order_letter in order:
            order_letter_set.add(order_letter)
            for i in range(letter_to_freq[order_letter]):
                res.append(order_letter)   
        for letter in s:
            if letter not in order_letter_set:
                res.append(letter)
        return ''.join(res)
                

```

### é¢˜ç›®2ï¼š560. Subarray Sum Equals K

```
Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.

A subarray is a contiguous non-empty sequence of elements within an array.

Example 1:

Input: nums = [1,1,1], k = 2
Output: 2
Example 2:

Input: nums = [1,2,3], k = 3
Output: 2

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/subarray-sum-equals-k
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```python

class Solution(object):
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        """
        [1,1,1], 2
        {0:1, 1:1, 2:1}
        cur_sum=3
        diff=0
        cnt=1

        """
        pre_sum_cnt = defaultdict(int)
        pre_sum_cnt[0] = 1
        cnt = 0
        cur_sum = 0
        for num in nums:
            cur_sum += num
            diff = cur_sum - k
            cnt += pre_sum_cnt[diff]
            pre_sum_cnt[cur_sum] += 1
            # print('pre_sum_cnt:', pre_sum_cnt)
        return cnt

```

## on-site

### Coding 1:Â 



#### LC 670. Maximum Swap
```
You are given an integer num. You can swap two digits at most once to get the maximum valued number.

Return the maximum valued number you can get.

 

Example 1:

Input: num = 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.
Example 2:

Input: num = 9973
Output: 9973
Explanation: No swap.
``


```python
class Solution(object):
    def maximumSwap(self, num):
        """
        :type num: int
        :rtype: int
        """

        num = list(str(num))
        n = len(num)
        swap_index = -1
        target_index = -1
        max_val = -1
        max_val_index = -1

        """
        i
               max_val = 7
               max_val_index = 1
             swap_index = 0
             target_index = 1
        [2,7,3,6]


           i
               max_val = 9
               max_val_index = 1
             swap_index = 2
             target_index = 3
        [3,9,9]
        """

        for i in range(n-1, -1, -1):
            if num[i] > max_val:
                max_val = num[i]
                max_val_index = i
            elif num[i] < max_val:
                swap_index = i
                target_index = max_val_index
        
        num[swap_index], num[target_index] = num[target_index], num[swap_index]
        return int(''.join(num))

```


#### ã€æ²¡åšå‡ºæ¥ã€‘LC 394. Decode String

```
Given an encoded string, return its decoded string.

The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.

You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].

The test cases are generated so that the length of the output will never exceed 105.

Example 1:

Input: s = "3[a]2[bc]"
Output: "aaabcbc"
Example 2:

Input: s = "3[a2[c]]"
Output: "accaccacc"
Example 3:

Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"

```

```python
class Solution(object):
    def decodeString(self, s):
        """
        :type s: str
        :rtype: str
        """

        """

        2[abc]3[4[b2[c]]]

        """
        n = len(s)
        cache = []
        cur = 0 # å½“å‰ç´¯è®¡çš„æ¬¡æ•°
        res = "" # å½“å‰ç´¯è®¡çš„å­—ç¬¦
        for i in range(n):
            if s[i].isdigit():
                cur = cur * 10 + int(s[i])
            elif s[i] == '[':
                cache.append([cur, res]) # æŠŠå‰é¢çš„ä¿æŠ¤èµ·æ¥
                res = ""
                cur = 0
            elif s[i] == ']':
                last_cur, last_res = cache.pop()
                res = last_res + last_cur * res
            else:
                res += s[i]
        return res

```


### Coding 2:Â Â 
#### LC 543. Follow up å¦‚æœæ˜¯general treeå‘¢ï¼Ÿ

```
Given the root of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

The length of a path between two nodes is represented by the number of edges between them.


Example 1:

Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
Example 2:

Input: root = [1,2]
Output: 1

```

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """

        self.diameter = 0

        def search(node):
            """return the depth of the node
            """
            if not node:
                return 0
            l = search(node.left)
            r = search(node.right)
            self.diameter = max(self.diameter, l + r)
            return max(l, r) + 1

        search(root)
        return self.diameter
```




# META ML RSè¿‡ç»åŠtimeline 2022-1-8

https://www.1point3acres.com/bbs/thread-837096-1-1.html


## åº—é¢

### é¢˜ç›®1:236. Lowest Common Ancestor of a Binary Tree

#### 1.1 é€’å½’æ€æƒ³

```python
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return root
        if root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        if left:
            return left
        return right
```
#### 1.2 ç”¨æ ˆè®°å½•path

```python
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        stack = []
        self.p_path = None
        self.q_path = None
        def search(node):
            if not node:
                return
            stack.append(node) # è¿›å…¥èŠ‚ç‚¹
            if node == p:
                self.p_path = stack[:]
            if node == q:
                self.q_path = stack[:]
            search(node.left)
            search(node.right)
            stack.pop() # å‡ºèŠ‚ç‚¹
        search(root)
        i = 0
        lowset_root = root
        while i < len(self.p_path) and i < len(self.q_path) and self.p_path[i].val == self.q_path[i].val:
            lowset_root = self.p_path[i]
            i += 1
        return lowset_root
```

### é¢˜ç›®2: 523. Continuous Subarray Sum
#### é¢˜ç›®ï¼š
```
Given an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to a multiple of k, or false otherwise.

An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.

Â 

Example 1:

Input: nums = [23,2,4,6,7], k = 6
Output: true
Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
Example 2:

Input: nums = [23,2,6,4,7], k = 6
Output: true
Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
Example 3:

Input: nums = [23,2,6,4,7], k = 13
Output: false

æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/continuous-subarray-sum
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

#### é¢˜è§£ï¼š
1. (m + k * n) % k = m % kï¼Œ å¦‚æœå½“å‰å’Œçš„ä½™æ•°å­˜åœ¨è¿‡ï¼Œé‚£ä¹ˆä¸­é—´å°±ä»£è¡¨åŠ äº†n*kï¼Œæ‰€ä»¥å°±æœ‰è¿ç»­çš„å’Œä¸ºn*k
2. æ³¨æ„0æ˜¯ä»»ä½•æ•°çš„å€æ•°ï¼Œä¾‹å¦‚[0, 0]å°±ä¸ºTrueï¼Œä½†æ˜¯é•¿åº¦è¦å¤§äº2ï¼Œæ‰€ä»¥[0]ä¸æ˜¯ã€‚
3. æ³¨æ„ä¸€äº›badcaseï¼Œä¾‹å¦‚ï¼š[6, 0ï¼Œ0]ä¹Ÿæ˜¯ä¸€ä¸ªç»“æœ
4. multipleå€æ•°ï¼Œ0æ˜¯ä»»ä½•æ•°çš„å€æ•°

```python
class Solution(object):
    def checkSubarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        (m + k * n) % k = m % k
        """
        n = len(nums)
        if n <= 1:
            return False
        d = dict()
        d[0] = -1 # corner case1 [2,4] 6,  corner case2 [0, 1] 6
        s = 0
        for i, num in enumerate(nums):
            s += num
            v = s % k
            if v in d:
                if i - d[v] > 1: #corner case2 [0, 1] 6
                    return True
            else:
                # æ¯æ¬¡è®°å½•ç¬¬ä¸€ä¸ªå‡ºç°çš„å°±è¡Œï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯é•¿åº¦å¤§äº2ï¼Œæ‰€ä»¥ä¸å­˜åœ¨çš„æ—¶å€™æ‰æ›´æ–°è¿›d
                d[v] = i
        return False
```



## on-site

### Round1(coding)ï¼šä¸‰é¢˜

#### 339. Nested List Weight Sum

- problem

```python
You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.

The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth.

Return the sum of each integer in nestedList multiplied by its depth.

Â 

Example 1:


Input: nestedList = [[1,1],2,[1,1]]
Output: 10
Explanation: Four 1's at depth 2, one 2 at depth 1. 1*2 + 1*2 + 2*1 + 1*2 + 1*2 = 10.
Example 2:


Input: nestedList = [1,[4,[6]]]
Output: 27
Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1*1 + 4*2 + 6*3 = 27.
Example 3:

Input: nestedList = [0]
Output: 0
Â 

Constraints:

1 <= nestedList.length <= 50
The values of the integers in the nested list is in the range [-100, 100].
The maximum depth of any integer is less than or equal to 50.

```

- code
```python
# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger(object):
#    def __init__(self, value=None):
#        """
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        """
#
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def add(self, elem):
#        """
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        """
#
#    def setInteger(self, value):
#        """
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """
class Solution(object):
    def depthSum(self, nestedList):
        """
        :type nestedList: List[NestedInteger]
        :rtype: int
        """
        self.depth = 1
        def search(curNestedList):
            s = 0
            for i in range(len(curNestedList)):
                val = curNestedList[i]
                if val.isInteger():
                    s += val.getInteger() * self.depth
                else:
                    self.depth += 1
                    s += search(val.getList())
                    self.depth -= 1
            return s

        return search(nestedList)

```

#### 133. Clone Graph

- é¢˜ç›®
```
Given a reference of a node in a connected undirected graph.

Return a deep copy (clone) of the graph.

Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.

class Node {
    public int val;
    public List<Node> neighbors;
}
 

Test case format:

For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.

An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.

The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.

 

Example 1:


Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]
Explanation: There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
Example 2:


Input: adjList = [[]]
Output: [[]]
Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
Example 3:

Input: adjList = []
Output: []
Explanation: This an empty graph, it does not have any nodes.
 

Constraints:

The number of nodes in the graph is in the range [0, 100].
1 <= Node.val <= 100
Node.val is unique for each node.
There are no repeated edges and no self-loops in the graph.
The Graph is connected and all nodes can be visited starting from the given node.
```

- dfsé¢˜è§£

```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution(object):
    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        
        self.node_to_clone = dict()
        def search(node):
            if not node:
                return None
            if node in self.node_to_clone:
                return self.node_to_clone[node]
            
            clone = Node(node.val)
            self.node_to_clone[node] = clone
            for child in node.neighbors:
                clone.neighbors.append(search(child))
            return clone
        return search(node)

```

- bfsé¢˜è§£

```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution(object):
    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if not node:
            return node
        copy = Node(node.val)
        d = deque()
        d.append([node, copy])
        visited = dict()
        visited[node] = copy
        while d:
            cur, copy = d.popleft()
            for child in cur.neighbors:
                if child not in visited:
                    child_copy = Node(child.val)
                    visited[child] = child_copy
                    d.append([child, child_copy])
                copy.neighbors.append(visited[child])
        return visited[node]

```


#### 227. Basic Calculator II

```
Given a string s which represents an expression, evaluate this expression and return its value. 

The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].

Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().

Example 1:

Input: s = "3+2*2"
Output: 7
Example 2:

Input: s = " 3/2 "
Output: 1
Example 3:

Input: s = " 3+5 / 2 "
Output: 5
```

- ç”¨stackè§£å†³
```python
class Solution(object):
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        """
        pre_mark = '+'
        val = 0
        res = []
        for i in range(len(s)):
            if s[i].isdigit():
                val = val * 10 + int(s[i])
            if (not s[i].isdigit() and s[i] != ' ') or i == len(s) - 1 :
                if pre_mark == '+':
                    res.append(val)
                elif pre_mark == '-':
                    res.append(-val)
                elif pre_mark == '*':
                    res[-1] *= val
                elif pre_mark == '/':
                    val_to_fix = 0
                    if res[-1] < 0 and (-res[-1]) % val > 0:
                        val_to_fix = 1
                    res[-1] /= val
                    res[-1] += val_to_fix
                pre_mark = s[i]
                val = 0
        return sum(res)
        
```

- ä¸ç”¨stackï¼Œå› ä¸ºåªéœ€è¦çœ‹æœ€è¿‘çš„ä¸¤ä¸ªå…ƒç´ å³å¯

```python
class Solution(object):
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        
        Input: s = "3+2*2"
        Output: 7
        
        l1=3
        l2=2*2
        
        2
        
        """
        pre_mark = '+'
        val = 0
        
        res = 0
        l1 = 0
        l2 = 0
        for i in range(len(s)):
            if s[i].isdigit():
                val = val * 10 + int(s[i])
            if (not s[i].isdigit() and s[i] != ' ') or i == len(s) - 1 :
                if pre_mark == '+':
                    res += l1
                    l1 = l2
                    l2 = val
                elif pre_mark == '-':
                    res += l1
                    l1 = l2
                    l2 = -val
                elif pre_mark == '*':
                    l2 *= val
                elif pre_mark == '/':
                    val_to_fix = 0
                    if l2 < 0 and (-l2) % val > 0:
                        val_to_fix = 1
                    l2 /= val
                    l2 += val_to_fix
                pre_mark = s[i]
                val = 0
        return res + l1 + l2
```
### Round2(coding)ï¼šä¸¤é¢˜

#### 65. Valid Number

```

A valid number can be split up into these components (in order):

A decimal number or an integer.
(Optional) An 'e' or 'E', followed by an integer.
A decimal number can be split up into these components (in order):

(Optional) A sign character (either '+' or '-').
One of the following formats:
One or more digits, followed by a dot '.'.
One or more digits, followed by a dot '.', followed by one or more digits.
A dot '.', followed by one or more digits.
An integer can be split up into these components (in order):

(Optional) A sign character (either '+' or '-').
One or more digits.
For example, all the following are valid numbers: ["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"], while the following are not valid numbers: ["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"].

Given a string s, return true if s is a valid number.

 

Example 1:

Input: s = "0"
Output: true
Example 2:

Input: s = "e"
Output: false
Example 3:

Input: s = "."
Output: false
```

```python
class Solution(object):

    def isValidFloat(self, val):
        val_split = val.split('.')
        if len(val_split) != 2:
            return False
        val_split = [_ for _ in val_split if _]
        if len(val_split) == 0:
            return False
        for tmp in val_split:
            if not tmp.isdigit():
                return False
        return True

    def isValidInt(self, val):
        # print('val:', val)
        if not val:
            # print('False')
            return False
        n = len(val)
        # print('val.isdigit():', val.isdigit())
        return val.isdigit()

        """
        "abc"
        "1a"
        "1e"
        "e3"
        "99e2.5"
        "--6"
        "-+3"
        "95a54e53"
        """
    def isNumber(self, s):
        """
        :type s: str
        :rtype: bool
        """

        """
        å°æ•°æˆ–è€…æ•´æ•° + eæˆ–è€…Eå†åŠ æ•´æ•°

        """
        s = s.replace(' ', '')
        if not s:
            return False
        if s == '.':
            return False
        s = s.lower()
        if s.find('e') == -1:
            if s[0] in ['+', '-']:
                return self.isValidInt(s[1:]) or self.isValidFloat(s[1:])
            else:
                return self.isValidInt(s) or self.isValidFloat(s)
        else:
            ls = s.split('e')
            if len(ls) != 2:
                return False
            ls = [_ for _ in ls if _]
            if len(ls) != 2:
                return False
            if ls[1][0] in ['+', '-']:
                if not self.isValidInt(ls[1][1:]):
                    return False
            else:
                if not self.isValidInt(ls[1]):
                    return False
            if ls[0][0] in ['+', '-']:
                if ls[0][1:]:
                    return self.isValidInt(ls[0][1:]) or self.isValidFloat(ls[0][1:])
                else:
                    return False
            else:
                return self.isValidInt(ls[0]) or self.isValidFloat(ls[0])

```

#### 670. Maximum Swap

```
You are given an integer num. You can swap two digits at most once to get the maximum valued number.

Return the maximum valued number you can get.

 

Example 1:

Input: num = 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.
Example 2:

Input: num = 9973
Output: 9973
Explanation: No swap.

```

```python
class Solution(object):
    def maximumSwap(self, num):
        """
        :type num: int
        :rtype: int
        """

        """
        27

        max_val_index=1
        max_val = 7
        left_index=2
             
           l  
        [2,7,3,6]

        é¢˜è§£ï¼šä»å³åˆ°å·¦éå†ï¼Œæ‰¾åˆ°æœ€å·¦è¾¹æ˜¯å¦å­˜åœ¨ä¸€ä¸ªæ•°ï¼Œå°äºå³è¾¹çš„æœ€å¤§å€¼ï¼Œå¦‚æœæœ‰ï¼Œåˆ™æŠŠå³è¾¹çš„æœ€å¤§å€¼ä¸æœ€å·¦è¾¹çš„è¿™ä¸ªå€¼æ›¿æ¢ã€‚
        """
        cache = []
        num = list(str(num))
        n = len(num)
        left_index_to_swap_index = dict()
        max_val_index = n - 1
        max_val = num[n-1]
        left_index = -1
        for i in range(n-2, -1, -1):
            if num[i] > max_val:
                max_val = num[i]
                max_val_index = i
            elif num[i] < max_val:
                left_index = i
                left_index_to_swap_index[left_index] = max_val_index
            # print('max_val_index:', max_val_index)
            # print('left_index:', left_index)
            # print("left_index_to_swap_index:", left_index_to_swap_index)
        
        if left_index != -1 and left_index < left_index_to_swap_index[left_index]:
            swap_index = left_index_to_swap_index[left_index]
            num[left_index], num[swap_index] = num[swap_index], num[left_index]
        
        return int(''.join(num))

```

### Round3(ML)


### Round3(BQ)


# Metaé«˜é¢‘
## åˆ†ç±»ä¸æ€»ç»“

### æ€»ç»“


### stack

#### 1249. Minimum Remove to Make Valid Parentheses

```
Given a string s of '(' , ')' and lowercase English characters.

Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:

It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
 

Example 1:

Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
Example 2:

Input: s = "a)b(c)d"
Output: "ab(c)d"
```

```python
class Solution(object):
    def minRemoveToMakeValid(self, s):
        """
        :type s: str
        :rtype: str

        "abc

        left=1
         right=

        a)b(c)d

        ((abc(d

        ['lee', [''], t, ['']]

        """

        left = 0
        left_index = []
        right = 0

        remove_index_set = set()

        for i in range(len(s)):
            if s[i] == '(':
                left_index.append(i)
                left += 1
            elif s[i] == ')':
                if left <= 0:
                    remove_index_set.add(i)
                else:
                    left -= 1
                    left_index.pop()
                # print("left_index:", left_index)

        while left_index:
            remove_index_set.add(left_index.pop())

        res = []
        for i in range(len(s)):
            if i not in remove_index_set:
                res.append(s[i])

        return ''.join(res)
        
```

## é«˜é¢‘é¢˜

#### 1249. Minimum Remove to Make Valid Parentheses

```
Given a string s of '(' , ')' and lowercase English characters.

Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:

It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
 

Example 1:

Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
Example 2:

Input: s = "a)b(c)d"
Output: "ab(c)d"
```

```python
class Solution(object):
    def minRemoveToMakeValid(self, s):
        """
        :type s: str
        :rtype: str

        "abc

        left=1
         right=

        a)b(c)d

        ((abc(d

        ['lee', [''], t, ['']]

        """

        left = 0
        left_index = []
        right = 0

        remove_index_set = set()

        for i in range(len(s)):
            if s[i] == '(':
                left_index.append(i)
                left += 1
            elif s[i] == ')':
                if left <= 0:
                    remove_index_set.add(i)
                else:
                    left -= 1
                    left_index.pop()
                # print("left_index:", left_index)

        while left_index:
            remove_index_set.add(left_index.pop())

        res = []
        for i in range(len(s)):
            if i not in remove_index_set:
                res.append(s[i])

        return ''.join(res)
        
```

#### 680. Valid Palindrome II

```
Given a string s, return true if the s can be palindrome after deleting at most one character from it.

Example 1:

Input: s = "aba"
Output: true
Example 2:

Input: s = "abca"
Output: true
Explanation: You could delete the character 'c'.
Example 3:

Input: s = "abc"
Output: false
```

```python

class Solution(object):
    def validPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """


        def is_valid_palindrom_between_left_and_right(l, r, delete_flag):
            while l <= r:
                if l == r:
                    return True
                if s[l] == s[r]:
                    if r - l <= 1:
                        return True
                    l += 1
                    r -= 1
                else:
                    if not delete_flag:
                        return is_valid_palindrom_between_left_and_right(l, r-1, True) or \
                            is_valid_palindrom_between_left_and_right(l+1, r, True)
                    else:
                        return False
            return False


        return is_valid_palindrom_between_left_and_right(0, len(s) - 1, False)
                

```
#### 953. Verifying an Alien Dictionary


```
In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.

Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.

 

Example 1:

Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
Output: true
Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.
Example 2:

Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
Output: false
Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.
```


```python

class Solution(object):
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """

        def slower_than(word1, word2, letter_start_index):
            """return True if word1 < word2"""

            for i in range(min(len(word1), len(word2))):
                letter1, letter2 = word1[i], word2[i]
                l1_index = ord(letter1) - ord('a')
                l2_index = ord(letter2) - ord('a')
                # print(letter1, letter2, l1_index, l2_index)
                if letter_start_index[l1_index] > letter_start_index[l2_index]:
                    return False
                elif letter_start_index[l1_index] < letter_start_index[l2_index]:
                    return True
            if len(word1) > len(word2):
                return False            
            return True


        letter_start_index = [float('inf')] * 26
        for i in range(len(order)):
            letter = order[i]
            if letter not in letter_start_index:
                letter_start_index[ord(letter) - ord('a')] = i

        for i in range(len(words) - 1):
            if not slower_than(words[i], words[i+1], letter_start_index):
                return False
        
        return True
```


#### 301. Remove Invalid Parentheses

```

Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.

Return all the possible results. You may return the answer in any order.

 

Example 1:

Input: s = "()())()"
Output: ["(())()","()()()"]
Example 2:

Input: s = "(a)())()"
Output: ["(a())()","(a)()()"]
Example 3:

Input: s = ")("
Output: [""]
```


```python
class Solution(object):
    def removeInvalidParentheses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """

        def is_valid(s1):
            if not s1:
                return True
            l, r = 0, 0
            for i in range(len(s1)):
                if s1[i] == '(':
                    l += 1
                elif s1[i] == ')':
                    if l <= 0:
                        return False
                    else:
                        l -= 1
            return l == r

        res = []
        def search(s1, l, r, start):
            # print("s1, l, r, start:", s1, l, r, start)
            if l == 0 and r == 0 and is_valid(s1):
                res.append(s1)
                # print('res:', res, 's1:' ,s1)
                return
            # 2. å…ˆå°è¯•åˆ é™¤å³æ‹¬å·ï¼Œå¦‚æœå…ˆåˆ é™¤å·¦æ‹¬å·ï¼Œä¼šå¯¼è‡´å¯èƒ½å·¦è¾¹æ›´å¤šæœ‰æ‹¬å·æ²¡æ³•åŒ¹é…
            if r > 0:
                for i in range(start, len(s1)):
                    # å»é‡
                    if i != start and s1[i] == s1[i-1]:
                        continue
                    # åˆ é™¤
                    if s1[i] == ')':
                        search(s1[:i]+s1[i+1:], l, r - 1, i)# å‡å»ç¬¬iä¸ªå…ƒç´ äº†ï¼Œä¸‹ä¸€ä¸ªè¿˜æ˜¯ä»iå¼€å§‹åˆ 
            elif l > 0:
                for i in range(start, len(s1)):
                    if i != start and s1[i] == s1[i-1]:
                        continue
                    if s1[i] == '(':
                        search(s1[:i]+s1[i+1:], l - 1, r, i)

        # 1. å…ˆç»Ÿè®¡å·¦å³å„éœ€è¦åˆ é™¤å¤šå°‘ä¸ªæ‹¬å·
        n = len(s)
        l, r = 0, 0
        for i in range(n):
            if s[i] == '(':
                l += 1
            elif s[i] == ')':
                if l <= 0:
                    r += 1
                else:
                    l -= 1

        search(s, l, r, 0)
        return res
```
#### 973. K Closest Points to Origin

```
Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).

The distance between two points on the X-Y plane is the Euclidean distance (i.e., âˆš(x1 - x2)2 + (y1 - y2)2).

You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).

Â 

Example 1:


Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].
Example 2:

Input: points = [[3,3],[5,-1],[-2,4]], k = 2
Output: [[3,3],[-2,4]]
Explanation: The answer [[-2,4],[3,3]] would also be accepted.

```

```python
class Solution(object):
    def kClosest(self, points, k):
        """
        :type points: List[List[int]]
        :type k: int
        :rtype: List[List[int]]
        """
        def get_dis(x1, y1):
            return x1 ** 2 + y1 ** 2

        dis = [[get_dis(points[i][0], points[i][1]), i] for i in range(len(points))]

        def find_k_closest_pointer(l, r, res_k):
            k1 = l - 1
            for i in range(l, r):
                if dis[i][0] <= dis[r][0]:
                    k1 += 1
                    dis[i], dis[k1] = dis[k1], dis[i]
            k1 += 1
            dis[r], dis[k1] = dis[k1], dis[r]
            if k1 - l + 1 == res_k:
                return [points[dis[i][1]] for i in range(k)]
            if res_k > k1 - l + 1:
                return find_k_closest_pointer(k1 + 1, r, res_k - (k1 - l + 1))
            else:
                return find_k_closest_pointer(l, k1 - 1, res_k)

        return find_k_closest_pointer(0, len(dis) - 1, k)
        
```

#### 67. Add Binary

```
Example 1:

Input: a = "11", b = "1"
Output: "100"
Example 2:

Input: a = "1010", b = "1011"
Output: "10101"
```

```python
class Solution(object):
    def addBinary(self, a, b):
        """
        :type a: str
        :type b: str
        :rtype: str
        """
        res = []
        add = 0
        m, n = len(a), len(b)
        for i in range(max(m, n)):
            if i < m:
                x = a[m - i - 1]
            else:
                x = 0
            if i < n:
                y = b[n - i - 1]
            else:
                y = 0
            s = int(x) + int(y) + add
            add = s // 2
            res.append(s % 2)
        if add:
            res.append(add)
        return ''.join([str(_) for _ in res[::-1]])
```
#### todolist [273, 301, 314, 125, 238, 938, 56, 215, 1762, 1570, 31, 199]

#### 273. Integer to English Words

```python
# Convert a non-negative integer num to its English words representation. 
# 
#  
#  Example 1: 
# 
#  
# Input: num = 123
# Output: "One Hundred Twenty Three"
#  
# 
#  Example 2: 
# 
#  
# Input: num = 12345
# Output: "Twelve Thousand Three Hundred Forty Five"
#  
# 
#  Example 3: 
# 
#  
# Input: num = 1234567
# Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty 
# Seven"
#  
# 
#  
#  Constraints: 
# 
#  
#  0 <= num <= 2Â³Â¹ - 1 
#  
# 
#  Related Topics é€’å½’ æ•°å­¦ å­—ç¬¦ä¸² ğŸ‘ 292 ğŸ‘ 0

class Solution(object):
    def numberToWords(self, num):
        """
        :type num: int
        :rtype: str
        """
        if num == 0:
            return "Zero"
        ones = ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
        teens = ["Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"]
        tens = ["Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"]
        thousands = [" Thousand", " Million", " Billion"]
        def search(num):
            s = ""
            # 1. if num biger than base, use recursion to get the result and return result,
            # be careful when mode == 0
            for i, base in enumerate([1000000000, 1000000, 1000]):
                if num >= base:
                    s += self.numberToWords(num // base) + thousands[2 - i]
                    if num % base != 0:
                        s += " " + self.numberToWords(num % base)
                    return s
            # 2. if num slower than 1000, check if it at range in [0, 10, 20, 100]
            if num < 1000:
                if num >= 100:
                    if num % 100 == 0:
                        s += self.numberToWords(num // 100) + " Hundred"
                    else:
                        s += self.numberToWords(num // 100) + " Hundred " + self.numberToWords(num % 100)
                elif num >= 20:
                    i = num // 10
                    if num % 10 == 0:
                        s += tens[i - 2]
                    else:
                        s += tens[i - 2] + " " + ones[num % 10 - 1]
                elif num >= 10:
                    s += teens[num - 10]
                else:
                    s += ones[num - 1]
            return s
        return search(num)

        
# runtime:24 ms
# memory:13.2 MB

```

#### 301. Remove Invalid Parentheses

```python
# Given a string s that contains parentheses and letters, remove the minimum 
# number of invalid parentheses to make the input string valid. 
# 
#  Return all the possible results. You may return the answer in any order. 
# 
#  
#  Example 1: 
# 
#  
# Input: s = "()())()"
# Output: ["(())()","()()()"]
#  
# 
#  Example 2: 
# 
#  
# Input: s = "(a)())()"
# Output: ["(a())()","(a)()()"]
#  
# 
#  Example 3: 
# 
#  
# Input: s = ")("
# Output: [""]
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= s.length <= 25 
#  s consists of lowercase English letters and parentheses '(' and ')'. 
#  There will be at most 20 parentheses in s. 
#  
# 
#  Related Topics å¹¿åº¦ä¼˜å…ˆæœç´¢ å­—ç¬¦ä¸² å›æº¯ ğŸ‘ 779 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    
    def calBracketNumNotMatched(self, s):
        l = 0
        r = 0
        for i in range(len(s)):
            if s[i] == ')':
                if l > 0:
                    l -= 1
                else:
                    r += 1
            elif s[i] == '(':
                l += 1
        return l, r

    def isValid(self, s):
        l, r = self.calBracketNumNotMatched(s)
        return l == 0 and r == 0
    
    def removeInvalidParentheses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """


        total_l_need_remove, total_r_need_remove = self.calBracketNumNotMatched(s)

        res = []
        def search(cur_s, l, r, start):
            # print(cur_s, l, r, start)
            if l == 0 and r == 0 and self.isValid(cur_s):
                res.append(cur_s)
                return
            if r > 0:
                for i in range(start, len(cur_s)):
                    if i != start and cur_s[i] == cur_s[i-1]:
                        continue
                    if cur_s[i] == ')':
                        search(cur_s[:i]+cur_s[i+1:], l, r - 1, i)
            elif l > 0:
                for i in range(start, len(cur_s)):
                    if i != start and cur_s[i] == cur_s[i-1]:
                        continue
                    if cur_s[i] == '(':
                        search(cur_s[:i]+cur_s[i+1:], l - 1, r, i)
        search(s, total_l_need_remove, total_r_need_remove, 0)
        return res
# runtime:20 ms
# memory:13 MB

# leetcode submit region end(Prohibit modification and deletion)

```

#### 314. Binary Tree Vertical Order Traversal

```python
# Given the root of a binary tree, return the vertical order traversal of its 
# nodes' values. (i.e., from top to bottom, column by column). 
# 
#  If two nodes are in the same row and column, the order should be from left 
# to right. 
# 
#  
#  Example 1: 
#  
#  
# Input: root = [3,9,20,null,null,15,7]
# Output: [[9],[3,15],[20],[7]]
#  
# 
#  Example 2: 
#  
#  
# Input: root = [3,9,8,4,0,1,7]
# Output: [[4],[9],[3,0,1],[8],[7]]
#  
# 
#  Example 3: 
#  
#  
# Input: root = [3,9,8,4,0,1,7,null,null,null,2,5]
# Output: [[4],[9,5],[3,0,1],[8,2],[7]]
#  
# 
#  
#  Constraints: 
# 
#  
#  The number of nodes in the tree is in the range [0, 100]. 
#  -100 <= Node.val <= 100 
#  
# 
#  Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ å“ˆå¸Œè¡¨ äºŒå‰æ ‘ ğŸ‘ 190 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def verticalOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        d = deque()
        d.append([root, 0])
        loc_to_node_list = defaultdict(list)
        min_loc = 0
        while d:
            cur, cur_loc = d.popleft()
            loc_to_node_list[cur_loc].append(cur.val)
            if cur.left:
                d.append([cur.left, cur_loc - 1])
            if cur.right:
                d.append([cur.right, cur_loc + 1])
            min_loc = min(cur_loc, min_loc)
        res = []
        for loc in range(min_loc, min_loc + len(loc_to_node_list)):
            res.append(loc_to_node_list[loc])
        return res
# runtime:16 ms
# memory:13.3 MB

# leetcode submit region end(Prohibit modification and deletion)


```

#### 125. Valid Palindrome

```python
# A phrase is a palindrome if, after converting all uppercase letters into 
# lowercase letters and removing all non-alphanumeric characters, it reads the same 
# forward and backward. Alphanumeric characters include letters and numbers. 
# 
#  Given a string s, return true if it is a palindrome, or false otherwise. 
# 
#  
#  Example 1: 
# 
#  
# Input: s = "A man, a plan, a canal: Panama"
# Output: true
# Explanation: "amanaplanacanalpanama" is a palindrome.
#  
# 
#  Example 2: 
# 
#  
# Input: s = "race a car"
# Output: false
# Explanation: "raceacar" is not a palindrome.
#  
# 
#  Example 3: 
# 
#  
# Input: s = " "
# Output: true
# Explanation: s is an empty string "" after removing non-alphanumeric 
# characters.
# Since an empty string reads the same forward and backward, it is a palindrome.
# 
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= s.length <= 2 * 10âµ 
#  s consists only of printable ASCII characters. 
#  
# 
#  Related Topics åŒæŒ‡é’ˆ å­—ç¬¦ä¸² ğŸ‘ 578 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        s_list = []
        for i in range(len(s)):
            if 'a'<=s[i]<='z' or 'A'<=s[i]<='Z' or '0'<=s[i]<='9':
                s_list.append(s[i].lower())
        # print('s_list:', s_list)
        l, r = 0, len(s_list) - 1
        while l < r:
            if s_list[l] == s_list[r]:
                l += 1
                r -= 1
            else:
                return False
        return True
        
# runtime:44 ms
# memory:17.9 MB

# leetcode submit region end(Prohibit modification and deletion)


```

#### [238]Product of Array Except Self

```python
# Given an integer array nums, return an array answer such that answer[i] is 
# equal to the product of all the elements of nums except nums[i]. 
# 
#  The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit 
# integer. 
# 
#  You must write an algorithm that runs in O(n) time and without using the 
# division operation. 
# 
#  
#  Example 1: 
#  Input: nums = [1,2,3,4]
# Output: [24,12,8,6]
#  
#  Example 2: 
#  Input: nums = [-1,1,0,-3,3]
# Output: [0,0,9,0,0]
#  
#  
#  Constraints: 
# 
#  
#  2 <= nums.length <= 10âµ 
#  -30 <= nums[i] <= 30 
#  The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit 
# integer. 
#  
# 
#  
#  Follow up: Can you solve the problem in O(1) extra space complexity? (The 
# output array does not count as extra space for space complexity analysis.) 
# 
#  Related Topics æ•°ç»„ å‰ç¼€å’Œ ğŸ‘ 1286 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def productExceptSelf(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """

        n = len(nums)
        l = [1] * n
        r = [1] * n

        for i in range(n):
            if i == 0:
                l[i] = nums[i]
                r[n-1-i] = nums[n-1-i]
            else:
                l[i] = l[i-1] * nums[i]
                r[n-1-i] = r[n-i] * nums[n-i-1]

        p = [0] * n
        for i in range(n):
            if i == 0:
                p[i] = r[i+1]
            elif i == n - 1:
                p[i] = l[i-1]
            else:
                p[i] = l[i-1] * r[i+1]
        return p
# runtime:60 ms
# memory:23.8 MB

# leetcode submit region end(Prohibit modification and deletion)


```

#### [938]Range Sum of BST

```python
# Given the root node of a binary search tree and two integers low and high, 
# return the sum of values of all nodes with a value in the inclusive range [low, 
# high]. 
# 
#  
#  Example 1: 
#  
#  
# Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
# Output: 32
# Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
#  
# 
#  Example 2: 
#  
#  
# Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
# Output: 23
# Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.
#  
# 
#  
#  Constraints: 
# 
#  
#  The number of nodes in the tree is in the range [1, 2 * 10â´]. 
#  1 <= Node.val <= 10âµ 
#  1 <= low <= high <= 10âµ 
#  All Node.val are unique. 
#  
# 
#  Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æœç´¢æ ‘ äºŒå‰æ ‘ ğŸ‘ 308 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def rangeSumBST(self, root, low, high):
        """
        :type root: TreeNode
        :type low: int
        :type high: int
        :rtype: int
        """
        self.sum = 0
        def search(node):
            if not node:
                return
            if node.val < low:
                search(node.right)
            elif node.val > high:
                search(node.left)
            else:
                self.sum += node.val
                search(node.left)
                search(node.right)
        search(root)
        return self.sum
# runtime:192 ms
# memory:28.9 MB

        
# leetcode submit region end(Prohibit modification and deletion)

```

#### [56]Merge Intervals
```python
# Given an array of intervals where intervals[i] = [starti, endi], merge all 
# overlapping intervals, and return an array of the non-overlapping intervals that 
# cover all the intervals in the input. 
# 
#  
#  Example 1: 
# 
#  
# Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
# Output: [[1,6],[8,10],[15,18]]
# Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
#  
# 
#  Example 2: 
# 
#  
# Input: intervals = [[1,4],[4,5]]
# Output: [[1,5]]
# Explanation: Intervals [1,4] and [4,5] are considered overlapping.
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= intervals.length <= 10â´ 
#  intervals[i].length == 2 
#  0 <= starti <= endi <= 10â´ 
#  
# 
#  Related Topics æ•°ç»„ æ’åº ğŸ‘ 1672 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """
        intervals.sort(key = lambda x:[x[0], -x[1]])
        res = []
        for i in range(len(intervals)):
            if not res:
                res.append(intervals[i])
            else:
                if intervals[i][0] > res[-1][1]:
                    res.append(intervals[i])
                else:
                    res[-1][1] = max(res[-1][1], intervals[i][1])
        return res
# runtime:36 ms
# memory:17.5 MB

# leetcode submit region end(Prohibit modification and deletion)

```

#### [215]Kth Largest Element in an Array

```python
# Given an integer array nums and an integer k, return the káµ—Ê° largest element 
# in the array. 
# 
#  Note that it is the káµ—Ê° largest element in the sorted order, not the káµ—Ê° 
# distinct element. 
# 
#  You must solve it in O(n) time complexity. 
# 
#  
#  Example 1: 
#  Input: nums = [3,2,1,5,6,4], k = 2
# Output: 5
#  
#  Example 2: 
#  Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
# Output: 4
#  
#  
#  Constraints: 
# 
#  
#  1 <= k <= nums.length <= 10âµ 
#  -10â´ <= nums[i] <= 10â´ 
#  
# 
#  Related Topics æ•°ç»„ åˆ†æ²» å¿«é€Ÿé€‰æ‹© æ’åº å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰ ğŸ‘ 1913 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """

        def search(l, r, k):
            mid = l + r >> 1
            nums[mid], nums[r] = nums[r], nums[mid]
            k1, k2 = l - 1, l
            while k2 < r:
                if nums[k2] > nums[r]:
                    k1 += 1
                    nums[k1], nums[k2] = nums[k2], nums[k1]
                k2 += 1
            k1 += 1
            nums[k1], nums[r] = nums[r], nums[k1]
            if k1 - l + 1 == k:
                return nums[k1]
            elif k1 - l + 1 > k:
                return search(l, k1 - 1, k)
            else:
                return search(k1 + 1, r, k - (k1 - l + 1))

        return search(0, len(nums) - 1, k)

# runtime:140 ms
# memory:25.4 MB

# leetcode submit region end(Prohibit modification and deletion)

```

#### [1762]Buildings With an Ocean View

```python
# There are n buildings in a line. You are given an integer array heights of 
# size n that represents the heights of the buildings in the line. 
# 
#  The ocean is to the right of the buildings. A building has an ocean view if 
# the building can see the ocean without obstructions. Formally, a building has an 
# ocean view if all the buildings to its right have a smaller height. 
# 
#  Return a list of indices (0-indexed) of buildings that have an ocean view, 
# sorted in increasing order. 
# 
#  
#  Example 1: 
# 
#  
# Input: heights = [4,2,3,1]
# Output: [0,2,3]
# Explanation: Building 1 (0-indexed) does not have an ocean view because 
# building 2 is taller.
#  
# 
#  Example 2: 
# 
#  
# Input: heights = [4,3,2,1]
# Output: [0,1,2,3]
# Explanation: All the buildings have an ocean view.
#  
# 
#  Example 3: 
# 
#  
# Input: heights = [1,3,2,4]
# Output: [3]
# Explanation: Only building 3 has an ocean view.
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= heights.length <= 10âµ 
#  1 <= heights[i] <= 10â¹ 
#  
# 
#  Related Topics æ ˆ æ•°ç»„ å•è°ƒæ ˆ ğŸ‘ 17 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def findBuildings(self, h):
        """
        :type heights: List[int]
        :rtype: List[int]

        h=[2,2]
        m=2
        1
        0
        """
        n = len(h)
        m = h[-1] - 1
        tmp = []
        for i in range(n-1, -1, -1):
            if h[i] > m:
                tmp.append(i)
                m = h[i]
        res = []
        while tmp:
            res.append(tmp.pop())
        return res
# runtime:68 ms
# memory:28.7 MB

# leetcode submit region end(Prohibit modification and deletion)

```

#### [1570]Dot Product of Two Sparse Vectors

```python
# Given two sparse vectors, compute their dot product. 
# 
#  Implement class SparseVector: 
# 
#  
#  SparseVector(nums) Initializes the object with the vector nums 
#  dotProduct(vec) Compute the dot product between the instance of SparseVector 
# and vec 
#  
# 
#  A sparse vector is a vector that has mostly zero values, you should store 
# the sparse vector efficiently and compute the dot product between two SparseVector.
#  
# 
#  Follow up: What if only one of the vectors is sparse? 
# 
#  
#  Example 1: 
# 
#  
# Input: nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]
# Output: 8
# Explanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
# v1.dotProduct(v2) = 1*0 + 0*3 + 0*0 + 2*4 + 3*0 = 8
#  
# 
#  Example 2: 
# 
#  
# Input: nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2]
# Output: 0
# Explanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
# v1.dotProduct(v2) = 0*0 + 1*0 + 0*0 + 0*0 + 0*2 = 0
#  
# 
#  Example 3: 
# 
#  
# Input: nums1 = [0,1,0,0,2,0,0], nums2 = [1,0,0,0,3,0,4]
# Output: 6
#  
# 
#  
#  Constraints: 
# 
#  
#  n == nums1.length == nums2.length 
#  1 <= n <= 10^5 
#  0 <= nums1[i], nums2[i] <= 100 
#  
# 
#  Related Topics è®¾è®¡ æ•°ç»„ å“ˆå¸Œè¡¨ åŒæŒ‡é’ˆ ğŸ‘ 25 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class SparseVector:
    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        data = list()
        for i, num in enumerate(nums):
            if num != 0:
                data.append([i, num])
        self.data = data
        

    # Return the dotProduct of two sparse vectors
    def dotProduct(self, vec):
        """
        :type vec: 'SparseVector'
        :rtype: int
        """
        s = 0
        m, n = len(self.data), len(vec.data)
        k1, k2 = 0, 0
        while k1 < m and k2 < n:
            if self.data[k1][0] == vec.data[k2][0]:
                s += self.data[k1][1] * vec.data[k2][1]
                k1 += 1
                k2 += 1
            elif self.data[k1][0] > vec.data[k2][0]:
                k2 += 1
            else:
                k1 += 1
        return s
        

# Your SparseVector object will be instantiated and called as such:
# v1 = SparseVector(nums1)
# v2 = SparseVector(nums2)
# ans = v1.dotProduct(v2)
# runtime:1512 ms
# memory:17.1 MB

        

# Your SparseVector object will be instantiated and called as such:
# v1 = SparseVector(nums1)
# v2 = SparseVector(nums2)
# ans = v1.dotProduct(v2)
# leetcode submit region end(Prohibit modification and deletion)

```

#### [31]Next Permutation

```python
# A permutation of an array of integers is an arrangement of its members into a 
# sequence or linear order. 
# 
#  
#  For example, for arr = [1,2,3], the following are all the permutations of 
# arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]. 
#  
# 
#  The next permutation of an array of integers is the next lexicographically 
# greater permutation of its integer. More formally, if all the permutations of the 
# array are sorted in one container according to their lexicographical order, 
# then the next permutation of that array is the permutation that follows it in the 
# sorted container. If such arrangement is not possible, the array must be 
# rearranged as the lowest possible order (i.e., sorted in ascending order). 
# 
#  
#  For example, the next permutation of arr = [1,2,3] is [1,3,2]. 
#  Similarly, the next permutation of arr = [2,3,1] is [3,1,2]. 
#  While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does 
# not have a lexicographical larger rearrangement. 
#  
# 
#  Given an array of integers nums, find the next permutation of nums. 
# 
#  The replacement must be in place and use only constant extra memory. 
# 
#  
#  Example 1: 
# 
#  
# Input: nums = [1,2,3]
# Output: [1,3,2]
#  
# 
#  Example 2: 
# 
#  
# Input: nums = [3,2,1]
# Output: [1,2,3]
#  
# 
#  Example 3: 
# 
#  
# Input: nums = [1,1,5]
# Output: [1,5,1]
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= nums.length <= 100 
#  0 <= nums[i] <= 100 
#  
# 
#  Related Topics æ•°ç»„ åŒæŒ‡é’ˆ ğŸ‘ 1937 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """


        """

        l
           r
        3654321

        4654321
        """

        n = len(nums)
        if n == 1:
            return
        i = n - 2
        find = False
        while i >= 0:
            if nums[i] < nums[i+1]:
                find = True
                break
            i -= 1
        
        if not find:
            nums.sort()
            return
        

        def find_first_index_bigger_than_target(target, l, r):
            """find target in num at range [l, r]"""
            cand = l
            while l <= r:
                m = l + r >> 1
                # print(target, l, r, m, nums[m])
                if nums[m] > target:
                    cand = m
                    l = m + 1
                elif nums[m] < target:
                    r = m - 1
                else:
                    r = m - 1
            return cand

        first_index = find_first_index_bigger_than_target(nums[i], i+1, len(nums) - 1)
        nums[i], nums[first_index] = nums[first_index], nums[i]
        # print(nums)
        l, r = i + 1, len(nums) - 1
        while l < r:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r -= 1
        
        return

# runtime:20 ms
# memory:12.9 MB

# leetcode submit region end(Prohibit modification and deletion)

```

#### [199]Binary Tree Right Side View

```python

# Given the root of a binary tree, imagine yourself standing on the right side 
# of it, return the values of the nodes you can see ordered from top to bottom. 
# 
#  
#  Example 1: 
#  
#  
# Input: root = [1,2,3,null,5,null,4]
# Output: [1,3,4]
#  
# 
#  Example 2: 
# 
#  
# Input: root = [1,null,3]
# Output: [1,3]
#  
# 
#  Example 3: 
# 
#  
# Input: root = []
# Output: []
#  
# 
#  
#  Constraints: 
# 
#  
#  The number of nodes in the tree is in the range [0, 100]. 
#  -100 <= Node.val <= 100 
#  
# 
#  Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘ ğŸ‘ 765 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        exist_layer = set()
        def dfs(root, layer):
            if not root:
                return
            if layer not in exist_layer:
                exist_layer.add(layer)
                res.append(root.val)
            dfs(root.right, layer + 1)
            dfs(root.left, layer + 1)
        dfs(root, 0)
        return res
# runtime:24 ms
# memory:13.1 MB

        
# leetcode submit region end(Prohibit modification and deletion)

```

#### todolist [528, 173, 415, 1, 29, 297, 278, 236, 253, 621, 91, 88, 543, 71, 50, 124, 10, 1650, 227, 138, 426, 133, 15, 158, 1428]

#### 528. Random Pick with Weight

```python
# You are given a 0-indexed array of positive integers w where w[i] describes 
# the weight of the iáµ—Ê° index. 
# 
#  You need to implement the function pickIndex(), which randomly picks an 
# index in the range [0, w.length - 1] (inclusive) and returns it. The probability of 
# picking an index i is w[i] / sum(w). 
# 
#  
#  For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3)
#  = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.7
# 5 (i.e., 75%). 
#  
# 
#  
#  Example 1: 
# 
#  
# Input
# ["Solution","pickIndex"]
# [[[1]],[]]
# Output
# [null,0]
# 
# Explanation
# Solution solution = new Solution([1]);
# solution.pickIndex(); // return 0. The only option is to return 0 since there 
# is only one element in w.
#  
# 
#  Example 2: 
# 
#  
# Input
# ["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
# [[[1,3]],[],[],[],[],[]]
# Output
# [null,1,1,1,1,0]
# 
# Explanation
# Solution solution = new Solution([1, 3]);
# solution.pickIndex(); // return 1. It is returning the second element (index =
#  1) that has a probability of 3/4.
# solution.pickIndex(); // return 1
# solution.pickIndex(); // return 1
# solution.pickIndex(); // return 1
# solution.pickIndex(); // return 0. It is returning the first element (index = 
# 0) that has a probability of 1/4.
# 
# Since this is a randomization problem, multiple answers are allowed.
# All of the following outputs can be considered correct:
# [null,1,1,1,1,0]
# [null,1,1,1,1,1]
# [null,1,1,1,0,0]
# [null,1,1,1,0,1]
# [null,1,0,1,0,0]
# ......
# and so on.
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= w.length <= 10â´ 
#  1 <= w[i] <= 10âµ 
#  pickIndex will be called at most 10â´ times. 
#  
# 
#  Related Topics æ•°å­¦ äºŒåˆ†æŸ¥æ‰¾ å‰ç¼€å’Œ éšæœºåŒ– ğŸ‘ 271 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
import random


class Solution(object):

    def __init__(self, w):
        """
        :type w: List[int]
        """
        s = float(sum(w))
        for i in range(len(w)):
            if i == 0:
                w[i] = w[i] / s
            else:
                w[i] = w[i-1] + w[i] / s
        self.w = w

    def pickIndex(self):
        """
        :rtype: int
        """
        val = random.random()
        if val <= self.w[0]:
            return 0
        l, r = 0, len(self.w) - 1
        while l <= r:
            m = l + r >> 1
            if self.w[m-1] < val <= self.w[m]:
                return m
            elif val > self.w[m]:
                l = m + 1
            else:
                r = m - 1



# Your Solution object will be instantiated and called as such:
# obj = Solution(w)
# param_1 = obj.pickIndex()
# leetcode submit region end(Prohibit modification and deletion)
```

#### 173. Binary Search Tree Iterator

```python
# Implement the BSTIterator class that represents an iterator over the in-order 
# traversal of a binary search tree (BST): 
# 
#  
#  BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. 
# The root of the BST is given as part of the constructor. The pointer should be 
# initialized to a non-existent number smaller than any element in the BST. 
#  boolean hasNext() Returns true if there exists a number in the traversal to 
# the right of the pointer, otherwise returns false. 
#  int next() Moves the pointer to the right, then returns the number at the 
# pointer. 
#  
# 
#  Notice that by initializing the pointer to a non-existent smallest number, 
# the first call to next() will return the smallest element in the BST. 
# 
#  You may assume that next() calls will always be valid. That is, there will 
# be at least a next number in the in-order traversal when next() is called. 
# 
#  
#  Example 1: 
#  
#  
# Input
# ["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", 
# "hasNext", "next", "hasNext"]
# [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
# Output
# [null, 3, 7, true, 9, true, 15, true, 20, false]
#  
# 
# Explanation
# BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
# bSTIterator.next(); // return 3
# bSTIterator.next(); // return 7
# bSTIterator.hasNext(); // return True
# bSTIterator.next(); // return 9
# bSTIterator.hasNext(); // return True
# bSTIterator.next(); // return 15
# bSTIterator.hasNext(); // return True
# bSTIterator.next(); // return 20
# bSTIterator.hasNext(); // return False
# 
# 
#  
#  Constraints: 
# 
#  
#  The number of nodes in the tree is in the range [1, 10âµ]. 
#  0 <= Node.val <= 10â¶ 
#  At most 10âµ calls will be made to hasNext, and next. 
#  
# 
#  
#  Follow up: 
# 
#  
#  Could you implement next() and hasNext() to run in average O(1) time and use 
# O(h) memory, where h is the height of the tree? 
#  
# 
#  Related Topics æ ˆ æ ‘ è®¾è®¡ äºŒå‰æœç´¢æ ‘ äºŒå‰æ ‘ è¿­ä»£å™¨ ğŸ‘ 648 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator(object):
    """
    æ€è·¯ï¼šä¸­åºéå†
    1. å…ˆå°†å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å·¦å­æ ‘å‹å…¥æ ˆï¼Œå‹åˆ°æ²¡æœ‰ä¸ºæ­¢
    2. å°†æœ€åä¸€ä¸ªå‹å…¥çš„èŠ‚ç‚¹å¼¹å‡ºï¼ˆæ ˆé¡¶å…ƒç´ ï¼‰ï¼ŒåŠ å…¥ç­”æ¡ˆ
    3. å°†å½“å‰å¼¹å‡ºçš„èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹ï¼Œé‡å¤æ­¥éª¤ä¸€
    """

    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.head = root
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def next(self):
        """
        :rtype: int
        """
        cur = self.stack.pop()
        root = cur.right
        while root:
            self.stack.append(root)
            root = root.left
        return cur.val
        

    def hasNext(self):
        """
        :rtype: bool
        """
        return len(self.stack) > 0
        


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
# leetcode submit region end(Prohibit modification and deletion)


```

#### 415. Add Strings


```pyhton
# Given two non-negative integers, num1 and num2 represented as string, return 
# the sum of num1 and num2 as a string. 
# 
#  You must solve the problem without using any built-in library for handling 
# large integers (such as BigInteger). You must also not convert the inputs to 
# integers directly. 
# 
#  
#  Example 1: 
# 
#  
# Input: num1 = "11", num2 = "123"
# Output: "134"
#  
# 
#  Example 2: 
# 
#  
# Input: num1 = "456", num2 = "77"
# Output: "533"
#  
# 
#  Example 3: 
# 
#  
# Input: num1 = "0", num2 = "0"
# Output: "0"
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= num1.length, num2.length <= 10â´ 
#  num1 and num2 consist of only digits. 
#  num1 and num2 don't have any leading zeros except for the zero itself. 
#  
# 
#  Related Topics æ•°å­¦ å­—ç¬¦ä¸² æ¨¡æ‹Ÿ ğŸ‘ 625 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def addStrings(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        m, n = len(num1), len(num2)
        add = 0
        k1, k2 = m - 1, n - 1
        res = []
        while k1 >= 0 or k2 >= 0:
            a = 0 if k1 < 0 else int(num1[k1])
            b = 0 if k2 < 0 else int(num2[k2])
            k1 -= 1
            k2 -= 1
            cur = a + b + add
            add = cur // 10
            cur = cur % 10
            res.append(str(cur))
        if add:
            res.append(str(add))
        return ''.join(res[::-1])


# leetcode submit region end(Prohibit modification and deletion)


```


#### 29 Divide Two Integers

```python
# Given two integers dividend and divisor, divide two integers without using 
# multiplication, division, and mod operator. 
# 
#  The integer division should truncate toward zero, which means losing its 
# fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be 
# truncated to -2. 
# 
#  Return the quotient after dividing dividend by divisor. 
# 
#  Note: Assume we are dealing with an environment that could only store 
# integers within the 32-bit signed integer range: [âˆ’2Â³Â¹, 2Â³Â¹ âˆ’ 1]. For this problem, if 
# the quotient is strictly greater than 2Â³Â¹ - 1, then return 2Â³Â¹ - 1, and if the 
# quotient is strictly less than -2Â³Â¹, then return -2Â³Â¹. 
# 
#  
#  Example 1: 
# 
#  
# Input: dividend = 10, divisor = 3
# Output: 3
# Explanation: 10/3 = 3.33333.. which is truncated to 3.
#  
# 
#  Example 2: 
# 
#  
# Input: dividend = 7, divisor = -3
# Output: -2
# Explanation: 7/-3 = -2.33333.. which is truncated to -2.
#  
# 
#  
#  Constraints: 
# 
#  
#  -2Â³Â¹ <= dividend, divisor <= 2Â³Â¹ - 1 
#  divisor != 0 
#  
# 
#  Related Topics ä½è¿ç®— æ•°å­¦ ğŸ‘ 991 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def divide(self, dividend, divisor):
        """
        :type dividend: int
        :type divisor: int
        :rtype: int
        10 / 3
        2^0, 2^1, 2^2
        3, 3+3, 3+3+3+3,
        base = 3
        cnt = 1
        """
        neg_flag = True if ((dividend > 0 and divisor <0) or (dividend < 0 and divisor > 0)) else False
        dividend = -dividend if dividend < 0 else dividend
        divisor = -divisor if divisor < 0 else divisor
        res = 0
        while dividend >= divisor:
            base = divisor
            cnt = 1
            while dividend - base > base:
                base += base
                cnt += cnt
            dividend -= base
            res += cnt
        if neg_flag:
            res = -res
        max_int = (1 << 31) - 1
        min_int = -(1 << 31)
        if res > max_int:
            return max_int
        if res < min_int:
            return min_int
        return res



# leetcode submit region end(Prohibit modification and deletion)


```

#### 297 Serialize and Deserialize Binary Tree

```python
# Serialization is the process of converting a data structure or object into a 
# sequence of bits so that it can be stored in a file or memory buffer, or 
# transmitted across a network connection link to be reconstructed later in the same or 
# another computer environment. 
# 
#  Design an algorithm to serialize and deserialize a binary tree. There is no 
# restriction on how your serialization/deserialization algorithm should work. You 
# just need to ensure that a binary tree can be serialized to a string and this 
# string can be deserialized to the original tree structure. 
# 
#  Clarification: The input/output format is the same as how LeetCode 
# serializes a binary tree. You do not necessarily need to follow this format, so please be 
# creative and come up with different approaches yourself. 
# 
#  
#  Example 1: 
#  
#  
# Input: root = [1,2,3,null,null,4,5]
# Output: [1,2,3,null,null,4,5]
#  
# 
#  Example 2: 
# 
#  
# Input: root = []
# Output: []
#  
# 
#  
#  Constraints: 
# 
#  
#  The number of nodes in the tree is in the range [0, 10â´]. 
#  -1000 <= Node.val <= 1000 
#  
# 
#  Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ è®¾è®¡ å­—ç¬¦ä¸² äºŒå‰æ ‘ ğŸ‘ 986 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ""
        path = []
        d = deque()
        d.append(root)
        while d:
            cur = d.popleft()
            if cur:
                path.append(str(cur.val))
                d.append(cur.left)
                d.append(cur.right)
            else:
                path.append("#")
        res = ','.join(path)
        # print(res)
        return res

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return None
        data = data.split(',')
        n = len(data)
        i = 0
        root = TreeNode(data[i])
        i += 1
        d = deque()
        d.append(root)
        while d:
            cur = d.popleft()
            if data[i] != '#':
                left = TreeNode(data[i])
                i += 1
                cur.left = left
                d.append(left)
            else:
                i += 1
            if data[i] != '#':
                right = TreeNode(data[i])
                i += 1
                cur.right = right
                d.append(right)
            else:
                i += 1
        # 1,2,3,null,null,4,5
        return root



        

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
# leetcode submit region end(Prohibit modification and deletion)


```

#### 278 First Bad Version

```python
# You are a product manager and currently leading a team to develop a new 
# product. Unfortunately, the latest version of your product fails the quality check. 
# Since each version is developed based on the previous version, all the versions 
# after a bad version are also bad. 
# 
#  Suppose you have n versions [1, 2, ..., n] and you want to find out the 
# first bad one, which causes all the following ones to be bad. 
# 
#  You are given an API bool isBadVersion(version) which returns whether 
# version is bad. Implement a function to find the first bad version. You should 
# minimize the number of calls to the API. 
# 
#  
#  Example 1: 
# 
#  
# Input: n = 5, bad = 4
# Output: 4
# Explanation:
# call isBadVersion(3) -> false
# call isBadVersion(5)Â -> true
# call isBadVersion(4)Â -> true
# Then 4 is the first bad version.
#  
# 
#  Example 2: 
# 
#  
# Input: n = 1, bad = 1
# Output: 1
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= bad <= n <= 2Â³Â¹ - 1 
#  
# 
#  Related Topics äºŒåˆ†æŸ¥æ‰¾ äº¤äº’ ğŸ‘ 809 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
# The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution(object):
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """

        l, r = 1, n
        cand = l
        while l <= r:
            mid = l + r >> 1
            if isBadVersion(mid):
                cand = mid
                r = mid - 1
            else:
                l = mid + 1
        return cand
# leetcode submit region end(Prohibit modification and deletion)


```

#### 236 Lowest Common Ancestor of a Binary Tree

```python
# Given a binary tree, find the lowest common ancestor (LCA) of two given nodes 
# in the tree. 
# 
#  According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor 
# is defined between two nodes p and q as the lowest node in T that has both p 
# and q as descendants (where we allow a node to be a descendant of itself).â€ 
# 
#  
#  Example 1: 
#  
#  
# Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
# Output: 3
# Explanation: The LCA of nodes 5 and 1 is 3.
#  
# 
#  Example 2: 
#  
#  
# Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
# Output: 5
# Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant 
# of itself according to the LCA definition.
#  
# 
#  Example 3: 
# 
#  
# Input: root = [1,2], p = 1, q = 2
# Output: 1
#  
# 
#  
#  Constraints: 
# 
#  
#  The number of nodes in the tree is in the range [2, 10âµ]. 
#  -10â¹ <= Node.val <= 10â¹ 
#  All Node.val are unique. 
#  p != q 
#  p and q will exist in the tree. 
#  
# 
#  Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘ ğŸ‘ 1997 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return root
        if root == p or root == q:
            return root
        l = self.lowestCommonAncestor(root.left, p, q)
        r = self.lowestCommonAncestor(root.right, p, q)
        if l and r:
            return root
        if l:
            return l
        return r
        
# leetcode submit region end(Prohibit modification and deletion)


```

#### 253 Meeting Rooms II

```python
# Given an array of meeting time intervals intervals where intervals[i] = [
# starti, endi], return the minimum number of conference rooms required. 
# 
#  
#  Example 1: 
#  Input: intervals = [[0,30],[5,10],[15,20]]
# Output: 2
#  
#  Example 2: 
#  Input: intervals = [[7,10],[2,4]]
# Output: 1
#  
#  
#  Constraints: 
# 
#  
#  1 <= intervals.length <= 10â´ 
#  0 <= starti < endi <= 10â¶ 
#  
# 
#  Related Topics è´ªå¿ƒ æ•°ç»„ åŒæŒ‡é’ˆ å‰ç¼€å’Œ æ’åº å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰ ğŸ‘ 479 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def minMeetingRooms(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: int
        intervals = [[0,30],[5,10],[15,20]]
        ç¬¬ä¸€ä¸ªäººä»0ä¸Šè½¦ï¼Œä»30ä¸‹è½¦ï¼›
        ç¬¬äºŒä¸ªäººä»5ä¸Šè½¦ï¼Œ10ä¸‹è½¦ã€‚ã€‚ã€‚
        äººæ•° 1    2     1     2     1      0
             0----5----10----15----20-----30
        å˜åŒ– +1   +1    -1    +1    -1    -1
        """
        res = []
        for x, y in intervals:
            res.append([x, 1])
            res.append([y, -1])
        max_cnt = 0
        cnt = 0
        res.sort(key = lambda x:x[0])
        # [[1,1],[13,1],[13,-1],[15,-1]]
        pre_time = res[0][0]
        for time, mark in res:
            if time != pre_time:
                max_cnt = max(max_cnt, cnt)
                pre_time = time
            cnt += mark
        max_cnt = max(max_cnt, cnt)
        return max_cnt




# leetcode submit region end(Prohibit modification and deletion)

```


#### 621. Task Scheduler

```python
# Given a characters array tasks, representing the tasks a CPU needs to do, 
# where each letter represents a different task. Tasks could be done in any order. 
# Each task is done in one unit of time. For each unit of time, the CPU could 
# complete either one task or just be idle. 
# 
#  However, there is a non-negative integer n that represents the cooldown 
# period between two same tasks (the same letter in the array), that is that there 
# must be at least n units of time between any two same tasks. 
# 
#  Return the least number of units of times that the CPU will take to finish 
# all the given tasks. 
# 
#  
#  Example 1: 
# 
#  
# Input: tasks = ["A","A","A","B","B","B"], n = 2
# Output: 8
# Explanation: 
# A -> B -> idle -> A -> B -> idle -> A -> B
# There is at least 2 units of time between any two same tasks.
#  
# 
#  Example 2: 
# 
#  
# Input: tasks = ["A","A","A","B","B","B"], n = 0
# Output: 6
# Explanation: On this case any permutation of size 6 would work since n = 0.
# ["A","A","A","B","B","B"]
# ["A","B","A","B","A","B"]
# ["B","B","B","A","A","A"]
# ...
# And so on.
#  
# 
#  Example 3: 
# 
#  
# Input: tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
# Output: 16
# Explanation: 
# One possible solution is
# A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle ->
#  idle -> A
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= task.length <= 10â´ 
#  tasks[i] is upper-case English letter. 
#  The integer n is in the range [0, 100]. 
#  
# 
#  Related Topics è´ªå¿ƒ æ•°ç»„ å“ˆå¸Œè¡¨ è®¡æ•° æ’åº å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰ ğŸ‘ 1032 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def leastInterval(self, tasks, n):
        """
        :type tasks: List[str]
        :type n: int
        :rtype: int
        """
        from collections import defaultdict
        wc = defaultdict(int)
        mc = 0
        for t in tasks:
            wc[t] += 1
            if wc[t] > mc:
                mc = wc[t]

        mcc = 0
        for k, c in wc.items():
            if c == mc:
                mcc += 1

        return max(len(tasks), (mc - 1) * (n + 1) + mcc)

# leetcode submit region end(Prohibit modification and deletion)

```


#### 91. Decode Ways

```python
# A message containing letters from A-Z can be encoded into numbers using the 
# following mapping: 
# 
#  
# 'A' -> "1"
# 'B' -> "2"
# ...
# 'Z' -> "26"
#  
# 
#  To decode an encoded message, all the digits must be grouped then mapped 
# back into letters using the reverse of the mapping above (there may be multiple 
# ways). For example, "11106" can be mapped into: 
# 
#  
#  "AAJF" with the grouping (1 1 10 6) 
#  "KJF" with the grouping (11 10 6) 
#  
# 
#  Note that the grouping (1 11 06) is invalid because "06" cannot be mapped 
# into 'F' since "6" is different from "06". 
# 
#  Given a string s containing only digits, return the number of ways to decode 
# it. 
# 
#  The test cases are generated so that the answer fits in a 32-bit integer. 
# 
#  
#  Example 1: 
# 
#  
# Input: s = "12"
# Output: 2
# Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).
#  
# 
#  Example 2: 
# 
#  
# Input: s = "226"
# Output: 3
# Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2
#  6).
#  
# 
#  Example 3: 
# 
#  
# Input: s = "06"
# Output: 0
# Explanation: "06" cannot be mapped to "F" because of the leading zero ("6" is 
# different from "06").
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= s.length <= 100 
#  s contains only digits and may contain leading zero(s). 
#  
# 
#  Related Topics å­—ç¬¦ä¸² åŠ¨æ€è§„åˆ’ ğŸ‘ 1274 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int

        12322
        11106
        """
        n = len(s)
        if s[0] == '0':
            return 0
        if n == 1:
            return 1
        pre1 = 1
        if s[1] == '0':
            if '1' <= s[0] <= '2':
                pre2 = 1
            else:
                return 0
        else:
            if "11" <= s[:2] <= "26":
                pre2 = 2
            else:
                pre2 = 1

        for i in range(2, n):
            if s[i] == '0':
                if s[i-1] == '0' or s[i-1] > '2':
                    return 0
                pre1, pre2 = pre2, pre1
            else:
                if "11" <= s[i-1:i+1] <= "26":
                    pre1, pre2 = pre2, pre1 + pre2
                else:
                    pre1, pre2 = pre2, pre2
        return pre2




# leetcode submit region end(Prohibit modification and deletion)


```

#### 88. Merge Sorted Array

```python
# You are given two integer arrays nums1 and nums2, sorted in non-decreasing 
# order, and two integers m and n, representing the number of elements in nums1 and 
# nums2 respectively. 
# 
#  Merge nums1 and nums2 into a single array sorted in non-decreasing order. 
# 
#  The final sorted array should not be returned by the function, but instead 
# be stored inside the array nums1. To accommodate this, nums1 has a length of m + 
# n, where the first m elements denote the elements that should be merged, and the 
# last n elements are set to 0 and should be ignored. nums2 has a length of n. 
# 
#  
#  Example 1: 
# 
#  
# Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
# Output: [1,2,2,3,5,6]
# Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
# The result of the merge is [1,2,2,3,5,6] with the underlined elements coming 
# from nums1.
#  
# 
#  Example 2: 
# 
#  
# Input: nums1 = [1], m = 1, nums2 = [], n = 0
# Output: [1]
# Explanation: The arrays we are merging are [1] and [].
# The result of the merge is [1].
#  
# 
#  Example 3: 
# 
#  
# Input: nums1 = [0], m = 0, nums2 = [1], n = 1
# Output: [1]
# Explanation: The arrays we are merging are [] and [1].
# The result of the merge is [1].
# Note that because m = 0, there are no elements in nums1. The 0 is only there 
# to ensure the merge result can fit in nums1.
#  
# 
#  
#  Constraints: 
# 
#  
#  nums1.length == m + n 
#  nums2.length == n 
#  0 <= m, n <= 200 
#  1 <= m + n <= 200 
#  -10â¹ <= nums1[i], nums2[j] <= 10â¹ 
#  
# 
#  
#  Follow up: Can you come up with an algorithm that runs in O(m + n) time? 
# 
#  Related Topics æ•°ç»„ åŒæŒ‡é’ˆ æ’åº ğŸ‘ 1598 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: None Do not return anything, modify nums1 in-place instead.
        """

        k1, k2 = 0, 0
        for i in range(m-1, -1, -1):
            nums1[i+n] = nums1[i]

        i = 0
        while k1 < m and k2 < n:
            if nums1[k1+n] == nums2[k2]:
                nums1[i] = nums1[k1+n]
                i += 1
                nums1[i] = nums2[k2]
                i += 1
                k1 += 1
                k2 += 1
            elif nums1[k1+n] > nums2[k2]:
                nums1[i] = nums2[k2]
                k2 += 1
                i += 1
            else:
                nums1[i] = nums1[k1+n]
                k1 += 1
                i += 1

        while k1 < m:
            nums1[i] = nums1[k1+n]
            i += 1
            k1 += 1
        while k2 < n:
            nums1[i] = nums2[k2]
            i += 1
            k2 += 1


s = Solution()
a = [1,2,3,0,0,0]
m =			3
b =			[2,5,6]
n =			3
print(s.merge(a, m, b, n))
# leetcode submit region end(Prohibit modification and deletion)


```

#### 543. Diameter of Binary Tree

```
Given the root of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

The length of a path between two nodes is represented by the number of edges between them.

Â 

Example 1:


Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
Example 2:

Input: root = [1,2]
Output: 1
```

```python

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """

        self.diameter = 0

        def search(node):
            """return the depth of the node
            """
            if not node:
                return 0
            l = search(node.left)
            r = search(node.right)
            self.diameter = max(self.diameter, l + r)
            return max(l, r) + 1

        search(root)
        return self.diameter
```


#### 50. Pow(x, n)

```
Implement pow(x, n), which calculates x raised to the power n (i.e., xn).

Â 

Example 1:

Input: x = 2.00000, n = 10
Output: 1024.00000
Example 2:

Input: x = 2.10000, n = 3
Output: 9.26100
Example 3:

Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25

```

```python
class Solution(object):
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        2**(10) = 2 ** (1010)
        1  2.      4            8
        2, 2*2=4, 2*2*2*2=16, (2*2*2*2)*(2*2*2*2)=16*16
        """
        if n < 0:
            return 1.0 / self.myPow(x, -n)
        i = 0
        s = 1
        while (1 << i) <= n:
            # print('x:',x,"1<<i:",1<<i)
            if (1 << i) & n:
                s *= x
            x *= x
            i += 1
        return s
```

#### 71. Simplify Path

```
Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.

In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.

The canonical path should have the following format:

The path starts with a single slash '/'.
Any two directories are separated by a single slash '/'.
The path does not end with a trailing '/'.
The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')
Return the simplified canonical path.

Â 

Example 1:

Input: path = "/home/"
Output: "/home"
Explanation: Note that there is no trailing slash after the last directory name.
Example 2:

Input: path = "/../"
Output: "/"
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.
Example 3:

Input: path = "/home//foo/"
Output: "/home/foo"
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.

```

```python

class Solution(object):
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """
        path = path.split('/')
        stack = []
        for val in path:
            if val:
                if val == '..':
                    if stack:
                        stack.pop()
                elif val != '.':
                    stack.append(val)
        return '/' + '/'.join(stack)
```

#### 10. Regular Expression Matching é”™è¯¯è§£æ³•

```python
class Solution(object):
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool


        ab a.
        a a* dp[i][j] = True if dp[i][j-1]
        aa a* dp[i][j] = True if dp[i-1][j] and p[j-2] == s[i-1]
        aaa a*
        """
        m, n = len(s), len(p)
        dp = [[False] * (n+1) for _ in range(m+1)]
        dp[0][0] = True
        if n >= 2 and p[1] == '*':
            dp[0][1] = True
        for j in range(3, n+1):
            if dp[0][j-2] and p[j-1] == '*':
                dp[0][j] = True
            # else:
                # break
        for i in range(1, m+1):
            for j in range(1, n+1):
                if s[i-1] == p[j-1] or p[j-1] == '.':
                    if dp[i-1][j-1]:
                        dp[i][j] = True
                elif p[j-1] == '*':
                    if j >= 2 and dp[i][j-2]:
                        dp[i][j] = True
                    if dp[i][j-1]:
                        dp[i][j] = True
                    if j >= 2 and dp[i-1][j] and (p[j-2] == s[i-1] or p[j-2] == '.'):
                        dp[i][j] = True

        for dpi in dp:
            print(dpi)
        return dp[m][n]

```

#### 10. Regular Expression Matching æ­£ç¡®è§£æ³•

```python
class Solution(object):
    def isMatch(self, s, p):
        """æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
        :type s: str
        :type p: str
        :rtype: bool
        Example:
            Input: s = "ab", p = ".*"
            Output: true
        Solution:
            1. å®Œå…¨ç›¸ç­‰æˆ–è€…é‡åˆ°.å¾€ä¸‹åŒ¹é…
            2. æ²¡æœ‰*ä¸å¯ä»¥åŒ¹é…äº†ï¼Œé‡åˆ°*ï¼Œè€ƒè™‘åŒ¹é…ä¸€æ¬¡æˆ–è€…ä¸¤æ¬¡ï¼Œæ‰€ä»¥é‡åˆ°*ï¼Œè¿˜æ˜¯è¦çœ‹å‰é¢çš„å­—æ¯
            3. æ€»ä½“æ¡†æ¶ï¼Œ
                1. æ˜¯å¦ç­‰ä»·æˆ–è€…ä¸º.
                2. ä¸º*
                    åŒ¹é…0ä¸ª
                    åŒ¹é…1ä¸ª
                    åŒ¹é…å¤šä¸ª
        """

        m = len(s)
        n = len(p)
        dp = [[False] * (n + 1) for _ in range(m + 1)]
        # åˆå§‹åŒ–
        dp[0][0] = True
        for j in range(1, n+1):
            if j-2 >= 0 and p[j-1] == '*' and dp[0][j-2]:
                dp[0][j] = True

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s[i-1] == p[j-1] or p[j-1] == '.':
                    dp[i][j] = dp[i-1][j-1]
                else:
                    if p[j-1] == "*":
                        # åŒ¹é…0ä¸ªï¼šb -> ba*
                        if j-2 >= 0 and dp[i][j-2]:
                            dp[i][j] = True
                        # 1ä¸ªï¼ša -> a*
                        if j-1 >= 0 and dp[i][j-1]:
                            dp[i][j] = True
                        # åŒ¹é…1ä¸ªæˆ–è€…å¤šä¸ª, éœ€è¦å‰é¢çš„ç›¸ç­‰
                        # baa vs ba*
                        # baaa vs ba*
                        if j-2>=0 and (p[j-2] == s[i-1] or p[j-2] == '.') \
                            and dp[i-1][j]:
                            dp[i][j] = True



        # for dpi in dp:
        #     print(dpi)

        return dp[m][n]

```

#### todolist [76, 269, 139, 523, 23, 200, 283, 65, 211, 347, 34, 721, 42, 339, 2, 987, 636, 121, 146, 162, 282, 17, 986, 43, 140]





# å…¶ä»–


#### 560 å­æ•°ç»„å’Œä¸ºkçš„ä¸ªæ•°

```python
class Solution(object):
    def subarraySum(self, nums, k):
        """å­æ•°ç»„å’Œä¸ºkçš„ä¸ªæ•°
        :type nums: List[int]
        :type k: int
        :rtype: int
        Example:
            #  Input: nums = [1,1,1], k = 2
            # Output: 2
        Solution:
            å‰ç¼€å’Œ+å“ˆå¸Œ
        """
        from collections import defaultdict
        # [1,1,1]
        # 1
        # cur_sum=3
        # pre_sum_cnt=[1:1, 2:1]
        # diff = 3-2=1
        # pre_sum = 1
        # cur_sum - pre_sum = k
        # pre_sum = cur_sum - k
        pre_sum_cnt = defaultdict(int)
        pre_sum_cnt[0] = 1
        pre_sum = 0
        cnt = 0
        for num in nums:
            cur_sum = pre_sum + num
            diff = cur_sum - k
            cnt += pre_sum_cnt[diff]
            pre_sum_cnt[cur_sum] += 1
            pre_sum = cur_sum
        return cnt

```


#### 791 å°†sä¸­çš„å­—æ¯æŒ‰orderçš„é¡ºåºè¿›è¡Œæ’åº

```python
class Solution(object):
    def customSortString(self, order, s):
        """å°†sä¸­çš„å­—æ¯æŒ‰orderçš„é¡ºåºè¿›è¡Œæ’åº
        é¢ç»åœ°å€ï¼šhttps://www.1point3acres.com/bbs/thread-650769-1-1.html
        :type order: str
        :type s: str
        :rtype: str
        Example:
            # Input: order = "cba", s = "abcd"
            # Output: "cbad"

            # Input: order = "cba", s = "abad"
            # Output: "baad" (è¦æ³¨æ„sä¸­å­—ç¬¦é‡å¤çš„é—®é¢˜)

        Solution:
            hashè¡¨
        """
        from collections import defaultdict
        letter_cnt = defaultdict(int)
        for letter in s:
            letter_cnt[letter] += 1
        order_letter_set = set()
        for letter in order:
            order_letter_set.add(letter)

        res = []
        for letter in order:
            if letter in letter_cnt:
                while letter_cnt[letter] > 0:
                    res.append(letter)
                    letter_cnt[letter] -= 1

        for letter in s:
            if letter not in order_letter_set:
                res.append(letter)

        return ''.join(res)

```


## å…¶ä»–èµ„æ–™

1. https://leetcode.com/problem-list/top-facebook-questions/
2. https://www.glassdoor.sg/Interview/Meta-Machine-Learning-Engineer-Interview-Questions-EI_IE40772.0,4_KO5,30.htm
3. è®°å½•æˆ‘æ›¾ç»é¢è¯• Facebookï¼ˆMetaï¼‰ çš„ç»å†ï¼šhttps://sichengingermay.com/facebook-interview/
4. Metaé¢è¯•ç»å†ï¼Œè¢«æ‹’ï¼Œä¸¤æ¬¡ï¼https://zhuanlan.zhihu.com/p/499547331