# ÊÄªÁªì

## Èù¢Á≠ãÊÄªÁªì
|Èù¢ËØïid|  Èù¢ËØïÁ±ªÂûã | Êó∂Èó¥  | È¢òÁõÆ | Á±ªÂûã | ÈöæÂ∫¶ | È¢òËß£ |
| ---- |  ----  | ----  | --- | --- | --- | --- |
| 1.MLE‰∏ÄÊù°ÈæôÊñ∞È≤úÈù¢Áªè |  Â∫óÈù¢-È¢òÁõÆ1  |2022.07| 791ÔºöCustom Sort String: ËÆ©sÊåâorderÊéíÂ∫èËæìÂá∫ | ÂìàÂ∏å+ÊéíÂ∫è | ‰∏≠Á≠â | ÂÖàÁªüËÆ°ÈúÄË¶ÅÊéíÂ∫èÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÁÑ∂ÂêéÊåâorderËæìÂá∫ÔºåÊ≥®ÊÑè‰∏çÂ≠òÂú®order‰∏≠ÁöÑÂ≠óÁ¨¶ |
| 1.MLE‰∏ÄÊù°ÈæôÊñ∞È≤úÈù¢Áªè |  Â∫óÈù¢-È¢òÁõÆ2  |2022.07| 560. Subarray Sum Equals KÔºöÂ≠êÂ∫èÂàóÂíå‰∏∫kÁöÑ‰∏™Êï∞ÔºåÊ≥®ÊÑèÊï∞Â≠óÂèØËÉΩ‰ΩçË¥üÊï∞  | ÂâçÁºÄÂíå | ‰∏≠Á≠âÂÅèÈöæ |ÁªüËÆ°ÊØè‰∏™ÂâçÁºÄÂíåÂá∫Áé∞ÁöÑÊ¨°Êï∞ÔºåÁªüËÆ°cur_pre_sum - targetÁöÑÊ¨°Êï∞Âç≥ÂèØÔºåÊ≥®ÊÑèpre_sum_cnt[0]=1, Ëß£ÂÜ≥[1,1] k=2 => 1ËøôÁßçÈóÆÈ¢ò |
| 1.MLE‰∏ÄÊù°ÈæôÊñ∞È≤úÈù¢Áªè |  on-site1-Coding 1  |2022.07| 670. Maximum SwapÔºöËøîÂõûÂè™ÂèØ‰ª•swap‰∏ÄÊ¨°ÂêéÊúÄÂ§ßÁöÑÊï∞| Êï∞ÁªÑ | ‰∏≠Á≠â |‰ªéÂêéÂæÄÂâçÈÅçÂéÜÂπ∂ËÆ∞ÂΩïÊúÄÂ§ßÂÄºÔºåÂØπÊØè‰∏™‰ΩçÁΩÆÔºå‰∏éÊõøÊç¢ÊúÄÂ§ßÂÄºÊõøÊç¢ÂèØ‰ª•ÂèñÂæóËØ•‰ΩçÁΩÆswapÂêéÁöÑÊúÄÂ§ßÂÄºÔºå‰∏éÊúÄÂâçÈù¢‰∏Ä‰∏™‰ΩçÁΩÆswapÂèØ‰ª•ÂèñÂæóÂÖ®Â±ÄÊúÄÂ§ßÂÄº|
| 1.MLE‰∏ÄÊù°ÈæôÊñ∞È≤úÈù¢Áªè |  on-site1-Coding 2  |2022.07| 394. Decode StringÔºöÂ∞Ü‰æãÂ¶ÇÂ§öÂ±ÇÂµåÂ•óÁöÑs=3[a3[c]]ËøõË°åËß£Á†Å|Ê†à| ‰∏≠Á≠âÂÅèÈöæ |Ê≥®ÊÑèÂè™‰ºöÂá∫Áé∞k[]ÁöÑÂΩ¢ÂºèÔºåÊâÄ‰ª•ÂèòÁÆÄÂçï‰∏ÄÁÇπÔºåÁî®pre_resËÆ∞ÂΩï‰πãÂâçÁ¥ØÁßØÁöÑÂ≠óÁ¨¶‰∏≤ÔºåcntËÆ∞ÂΩïÊã¨Âè∑ÂâçÁöÑÊï∞Â≠ó, resËÆ∞ÂΩïÂΩìÂâçÁöÑÂ≠óÁ¨¶ÔºåÈÅáÂà∞]ÂèØ‰ª•Êõ¥Êñ∞res=pre_res + cnt * resÔºå ÈÅáÂà∞[ÂèØ‰ª•Â∞ÜÂâçÈù¢ÁöÑpre_resÂíåÊï∞Â≠ócntÂéãÂÖ•Ê†à|
| 1.MLE‰∏ÄÊù°ÈæôÊñ∞È≤úÈù¢Áªè |  on-site1-Coding 3  |2022.07| 543. diameter of the treeÔºö Ê†ëÁöÑÁõ¥ÂæÑ|Ê†ë|‰∏≠Á≠â|ÂêéÁª≠ÈÅçÂéÜ+ÊØèÊ¨°ÁªüËÆ°Ê†ëÁöÑÊ∑±Â∫¶+Âà©Áî®ÂêéÁª≠ÈÅçÂéÜËÆ°ÁÆóÂåÖÂê´ÂΩìÂâçËäÇÁÇπÁöÑÁõ¥ÂæÑ|
| 2. META ML RSËøáÁªèÂèätimeline |  Â∫óÈù¢-Coding 1  |2022.01| Lowest Common Ancestor of a Binary TreeÔºö ‰∏§‰∏™ËäÇÁÇπÁöÑÊúÄÂ∞èÂÖ¨ÂÖ±Á•ñÂÖà|Ê†ë|‰∏≠Á≠â|ÊñπÊ≥ï1: ÈÄíÂΩíÔºöÂΩìÂâçËäÇÁÇπÁöÑËæìÂá∫ÂèØ‰ª•Áî±Â∑¶Â≠©Â≠êÊàñËÄÖÂè≥Â≠©Â≠êËÉΩËøîÂõûÁªìÊûúÊù•ÂÆöÔºåÂ¶ÇÊûúÂ∑¶Â≠©Â≠êÊàñËÄÖÂè≥Â≠©Â≠êÈÉΩ‰∏ç‰∏∫Á©∫ÔºåÈÇ£‰πàËøîÂõûÂΩìÂâçËäÇÁÇπ„ÄÇÂê¶ÂàôËøîÂõû‰∏§ËÄÖ‰πã‰∏Ä„ÄÇÊñπÊ≥ï2: Ê†àÔºöË∑üË∏™Ë∑üËäÇÁÇπÂà∞ÂΩìÂâçËäÇÁÇπÁöÑÁöÑpath(ÂÖàÂ∫èÈÅçÂéÜÂÖ•Ê†àÔºåÂêéÁª≠ÈÅçÂéÜÂá∫Ê†àÂèØ)ÔºåÁÑ∂ÂêéÊØîËæÉ‰∏§‰∏™ËäÇÁÇπÁöÑpathÔºåÊâæÂá∫ÊúÄ‰ΩéÁöÑancestor|
| 2. META ML RSËøáÁªèÂèätimeline |  Â∫óÈù¢-Coding 2  |2022.01| 523. Continuous Subarray SumÔºöÊòØÂê¶Â≠òÂú®ÈïøÂ∫¶Â§ß‰∫é2ÁöÑËøûÁª≠Âíå‰∏∫kÁöÑÂ≠êÊï∞ÁªÑ |Êï∞ÁªÑ+Êï∞Â≠¶|‰∏≠Á≠âÈÄöËøáÁéá30%|ÂâçÁºÄÂíåÂØπkÂèñ‰ΩôÊï∞ÔºåÂ¶ÇÊûú‰ΩôÊï∞modÁõ∏Á≠âÔºåÈÇ£‰πà‰ª£Ë°®‰∏≠Èó¥ÁöÑÈÇ£ÊÆµÊï∞‰∏∫kÁöÑÂÄçÊï∞ÔºåË¶ÅÊ≥®ÊÑè[1,1] k=2ËøôÁßçÊÉÖÂÜµÔºåÂèØ‰ª•Âè¶pre_mod_index[0]=-1|
| 2. META ML RSËøáÁªèÂèätimeline |  on-site1-Coding 1  |2022.01| 339. Nested List Weight SumÔºöÂ§öÈáçÂµåÂ•óÊï∞ÁªÑÂíå|Ê†à|‰∏≠Á≠â|ÈÄíÂΩíÔºöÂÖàÂ∫èÈÅçÂéÜdepth+1ÔºåÂêéÁª≠ÈÅçÂéÜdepth-1ÔºåËøôÊ†∑ËæìÂá∫Âíå|
| 2. META ML RSËøáÁªèÂèätimeline |  on-site1-Coding 2  |2022.01| 133. Clone GraphÔºöÂÖãÈöÜÊó†ÂêëÂõæ|dfsÊàñËÄÖbfs|‰∏≠Á≠â|Áî®Â≠óÂÖ∏ËÆ∞ÂΩïÊØè‰∏™ËäÇÁÇπÂà∞ÂÖ∂copyËäÇÁÇπÁöÑÊò†Â∞ÑÔºåÁÑ∂ÂêéÁî®bfsÊ±ÇËß£ÔºåÊØîËæÉÊñπ‰æø|
| 2. META ML RSËøáÁªèÂèätimeline |  on-site1-Coding 3  |2022.01| Basic Calculator II: ËÆ°ÁÆóÊó†Êã¨Âè∑ÁöÑÂä†Âáè‰πòÂàùÁöÑÁªìÊûú|Ê†à or ‰ºòÂåñÁâàÊú¨|‰∏≠Á≠â|1. Âè™ÈúÄË¶ÅËÆ∞ÂΩïans(‰∏ä‰∏™‰ΩçÁΩÆ‰πãÂâçÁöÑÁªìÊûú)Ôºåpre_val(‰∏ä‰∏Ä‰∏™‰ΩçÁΩÆÁªìÊûú)Ôºåcur_val(ÂΩìÂâç‰ΩçÁΩÆÁªìÊûú)Ëøô‰∏â‰∏™Êï∞ÔºåÂèØ‰ª•Â∞ÜÁ©∫Èó¥Â§çÊùÇÂ∫¶‰ºòÂåñÂà∞O(1). 2.ÈÅáÂà∞+-*/Á¨¶Âè∑ÊàñËÄÖÂà∞ÁªìÊùü‰ΩçÁΩÆÂ∞±ËÆ°ÁÆóÁªìÊûú|
| 2. META ML RSËøáÁªèÂèätimeline |  on-site2-Coding 1  |2022.07| 65. Valid Number: ÊòØÂê¶‰∏∫ÊúâÊïàÁöÑfloatÊï∞ÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÂèØËÉΩÂåÖÂê´.+-eEÁ≠âÁ¨¶Âè∑| Â≠óÁ¨¶‰∏≤ | ‰∏≠Á≠â |Ê≥®ÊÑèÂæàÂ§öbadcase|
| 2. META ML RSËøáÁªèÂèätimeline |  on-site2-Coding 1  |2022.07| 670. Maximum SwapÔºöËøîÂõûÂè™ÂèØ‰ª•swap‰∏ÄÊ¨°ÂêéÊúÄÂ§ßÁöÑÊï∞| Êï∞ÁªÑ | ‰∏≠Á≠â |‰ªéÂêéÂæÄÂâçÈÅçÂéÜÂπ∂ËÆ∞ÂΩïÊúÄÂ§ßÂÄºÔºåÂØπÊØè‰∏™‰ΩçÁΩÆÔºå‰∏éÊõøÊç¢ÊúÄÂ§ßÂÄºÊõøÊç¢ÂèØ‰ª•ÂèñÂæóËØ•‰ΩçÁΩÆswapÂêéÁöÑÊúÄÂ§ßÂÄºÔºå‰∏éÊúÄÂâçÈù¢‰∏Ä‰∏™‰ΩçÁΩÆswapÂèØ‰ª•ÂèñÂæóÂÖ®Â±ÄÊúÄÂ§ßÂÄº|

## È´òÈ¢ëÈ¢òÊÄªÁªì
|Á±ªÂûã|  È¢òÂè∑ | ÈöæÂ∫¶  | È¢òÁõÆ | È¢òËß£ | 
| ---- |  ----  | ----  | --- | --- |

# [Èù¢ËØïÁªèÈ™å] FB MLE‰∏ÄÊù°ÈæôÊñ∞È≤úÈù¢Áªè
https://www.1point3acres.com/bbs/thread-650769-1-1.html

## Â∫óÈù¢

### È¢òÁõÆ1Ôºö791. Custom Sort String

```
791. Custom Sort String
You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.

Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.

Return any permutation of s that satisfies this property.

Example 1:

Input: order = "cba", s = "abcd"
Output: "cbad"
Explanation: 
"a", "b", "c" appear in order, so the order of "a", "b", "c" should be "c", "b", and "a". 
Since "d" does not appear in order, it can be at any position in the returned string. "dcba", "cdba", "cbda" are also valid outputs.
Example 2:

Input: order = "cbafg", s = "abcd"
Output: "cbad"
```

```python
class Solution(object):
    def customSortString(self, order, s):
        """
        :type order: str
        :type s: str
        :rtype: str
        """
        letter_to_freq = defaultdict(int)
        for letter in s:
            letter_to_freq[letter] += 1
        res = []
        order_letter_set = set()
        for order_letter in order:
            order_letter_set.add(order_letter)
            for i in range(letter_to_freq[order_letter]):
                res.append(order_letter)   
        for letter in s:
            if letter not in order_letter_set:
                res.append(letter)
        return ''.join(res)
                

```

### È¢òÁõÆ2Ôºö560. Subarray Sum Equals K

```
Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.

A subarray is a contiguous non-empty sequence of elements within an array.

Example 1:

Input: nums = [1,1,1], k = 2
Output: 2
Example 2:

Input: nums = [1,2,3], k = 3
Output: 2

Êù•Ê∫êÔºöÂäõÊâ£ÔºàLeetCodeÔºâ
ÈìæÊé•Ôºöhttps://leetcode.cn/problems/subarray-sum-equals-k
Ëëó‰ΩúÊùÉÂΩíÈ¢ÜÊâ£ÁΩëÁªúÊâÄÊúâ„ÄÇÂïÜ‰∏öËΩ¨ËΩΩËØ∑ËÅîÁ≥ªÂÆòÊñπÊéàÊùÉÔºåÈùûÂïÜ‰∏öËΩ¨ËΩΩËØ∑Ê≥®ÊòéÂá∫Â§Ñ„ÄÇ
```

```python

class Solution(object):
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        """
        [1,1,1], 2
        {0:1, 1:1, 2:1}
        cur_sum=3
        diff=0
        cnt=1

        """
        pre_sum_cnt = defaultdict(int)
        pre_sum_cnt[0] = 1
        cnt = 0
        cur_sum = 0
        for num in nums:
            cur_sum += num
            diff = cur_sum - k
            cnt += pre_sum_cnt[diff]
            pre_sum_cnt[cur_sum] += 1
            # print('pre_sum_cnt:', pre_sum_cnt)
        return cnt

```

## on-site

### Coding 1:¬†



#### LC 670. Maximum Swap
```
You are given an integer num. You can swap two digits at most once to get the maximum valued number.

Return the maximum valued number you can get.

 

Example 1:

Input: num = 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.
Example 2:

Input: num = 9973
Output: 9973
Explanation: No swap.
``


```python
class Solution(object):
    def maximumSwap(self, num):
        """
        :type num: int
        :rtype: int
        """

        num = list(str(num))
        n = len(num)
        swap_index = -1
        target_index = -1
        max_val = -1
        max_val_index = -1

        """
        i
               max_val = 7
               max_val_index = 1
             swap_index = 0
             target_index = 1
        [2,7,3,6]


           i
               max_val = 9
               max_val_index = 1
             swap_index = 2
             target_index = 3
        [3,9,9]
        """

        for i in range(n-1, -1, -1):
            if num[i] > max_val:
                max_val = num[i]
                max_val_index = i
            elif num[i] < max_val:
                swap_index = i
                target_index = max_val_index
        
        num[swap_index], num[target_index] = num[target_index], num[swap_index]
        return int(''.join(num))

```


#### „ÄêÊ≤°ÂÅöÂá∫Êù•„ÄëLC 394. Decode String

```
Given an encoded string, return its decoded string.

The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.

You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].

The test cases are generated so that the length of the output will never exceed 105.

Example 1:

Input: s = "3[a]2[bc]"
Output: "aaabcbc"
Example 2:

Input: s = "3[a2[c]]"
Output: "accaccacc"
Example 3:

Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"

```

```python
class Solution(object):
    def decodeString(self, s):
        """
        :type s: str
        :rtype: str
        """

        """

        2[abc]3[4[b2[c]]]

        """
        n = len(s)
        cache = []
        cur = 0 # ÂΩìÂâçÁ¥ØËÆ°ÁöÑÊ¨°Êï∞
        res = "" # ÂΩìÂâçÁ¥ØËÆ°ÁöÑÂ≠óÁ¨¶
        for i in range(n):
            if s[i].isdigit():
                cur = cur * 10 + int(s[i])
            elif s[i] == '[':
                cache.append([cur, res]) # ÊääÂâçÈù¢ÁöÑ‰øùÊä§Ëµ∑Êù•
                res = ""
                cur = 0
            elif s[i] == ']':
                last_cur, last_res = cache.pop()
                res = last_res + last_cur * res
            else:
                res += s[i]
        return res

```


### Coding 2:¬†¬†
#### LC 543. Follow up Â¶ÇÊûúÊòØgeneral treeÂë¢Ôºü

```
Given the root of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

The length of a path between two nodes is represented by the number of edges between them.


Example 1:

Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
Example 2:

Input: root = [1,2]
Output: 1

```

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """

        self.diameter = 0

        def search(node):
            """return the depth of the node
            """
            if not node:
                return 0
            l = search(node.left)
            r = search(node.right)
            self.diameter = max(self.diameter, l + r)
            return max(l, r) + 1

        search(root)
        return self.diameter
```




# META ML RSËøáÁªèÂèätimeline 2022-1-8

https://www.1point3acres.com/bbs/thread-837096-1-1.html


## Â∫óÈù¢

### È¢òÁõÆ1:236. Lowest Common Ancestor of a Binary Tree

#### 1.1 ÈÄíÂΩíÊÄùÊÉ≥

```python
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return root
        if root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        if left:
            return left
        return right
```
#### 1.2 Áî®Ê†àËÆ∞ÂΩïpath

```python
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        stack = []
        self.p_path = None
        self.q_path = None
        def search(node):
            if not node:
                return
            stack.append(node) # ËøõÂÖ•ËäÇÁÇπ
            if node == p:
                self.p_path = stack[:]
            if node == q:
                self.q_path = stack[:]
            search(node.left)
            search(node.right)
            stack.pop() # Âá∫ËäÇÁÇπ
        search(root)
        i = 0
        lowset_root = root
        while i < len(self.p_path) and i < len(self.q_path) and self.p_path[i].val == self.q_path[i].val:
            lowset_root = self.p_path[i]
            i += 1
        return lowset_root
```

### È¢òÁõÆ2: 523. Continuous Subarray Sum
#### È¢òÁõÆÔºö
```
Given an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to a multiple of k, or false otherwise.

An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.

¬†

Example 1:

Input: nums = [23,2,4,6,7], k = 6
Output: true
Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
Example 2:

Input: nums = [23,2,6,4,7], k = 6
Output: true
Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
Example 3:

Input: nums = [23,2,6,4,7], k = 13
Output: false

Êù•Ê∫êÔºöÂäõÊâ£ÔºàLeetCodeÔºâ
ÈìæÊé•Ôºöhttps://leetcode.cn/problems/continuous-subarray-sum
Ëëó‰ΩúÊùÉÂΩíÈ¢ÜÊâ£ÁΩëÁªúÊâÄÊúâ„ÄÇÂïÜ‰∏öËΩ¨ËΩΩËØ∑ËÅîÁ≥ªÂÆòÊñπÊéàÊùÉÔºåÈùûÂïÜ‰∏öËΩ¨ËΩΩËØ∑Ê≥®ÊòéÂá∫Â§Ñ„ÄÇ
```

#### È¢òËß£Ôºö
1. (m + k * n) % k = m % kÔºå Â¶ÇÊûúÂΩìÂâçÂíåÁöÑ‰ΩôÊï∞Â≠òÂú®ËøáÔºåÈÇ£‰πà‰∏≠Èó¥Â∞±‰ª£Ë°®Âä†‰∫Ün*kÔºåÊâÄ‰ª•Â∞±ÊúâËøûÁª≠ÁöÑÂíå‰∏∫n*k
2. Ê≥®ÊÑè0ÊòØ‰ªª‰ΩïÊï∞ÁöÑÂÄçÊï∞Ôºå‰æãÂ¶Ç[0, 0]Â∞±‰∏∫TrueÔºå‰ΩÜÊòØÈïøÂ∫¶Ë¶ÅÂ§ß‰∫é2ÔºåÊâÄ‰ª•[0]‰∏çÊòØ„ÄÇ
3. Ê≥®ÊÑè‰∏Ä‰∫õbadcaseÔºå‰æãÂ¶ÇÔºö[6, 0Ôºå0]‰πüÊòØ‰∏Ä‰∏™ÁªìÊûú
4. multipleÂÄçÊï∞Ôºå0ÊòØ‰ªª‰ΩïÊï∞ÁöÑÂÄçÊï∞

```python
class Solution(object):
    def checkSubarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        (m + k * n) % k = m % k
        """
        n = len(nums)
        if n <= 1:
            return False
        d = dict()
        d[0] = -1 # corner case1 [2,4] 6,  corner case2 [0, 1] 6
        s = 0
        for i, num in enumerate(nums):
            s += num
            v = s % k
            if v in d:
                if i - d[v] > 1: #corner case2 [0, 1] 6
                    return True
            else:
                # ÊØèÊ¨°ËÆ∞ÂΩïÁ¨¨‰∏Ä‰∏™Âá∫Áé∞ÁöÑÂ∞±Ë°åÔºåËøôÊ†∑Â∞±ÂèØ‰ª•‰øùËØÅÈïøÂ∫¶Â§ß‰∫é2ÔºåÊâÄ‰ª•‰∏çÂ≠òÂú®ÁöÑÊó∂ÂÄôÊâçÊõ¥Êñ∞Ëøõd
                d[v] = i
        return False
```



## on-site

### Round1(coding)Ôºö‰∏âÈ¢ò

#### 339. Nested List Weight Sum

- problem

```python
You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists.

The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer's value set to its depth.

Return the sum of each integer in nestedList multiplied by its depth.

¬†

Example 1:


Input: nestedList = [[1,1],2,[1,1]]
Output: 10
Explanation: Four 1's at depth 2, one 2 at depth 1. 1*2 + 1*2 + 2*1 + 1*2 + 1*2 = 10.
Example 2:


Input: nestedList = [1,[4,[6]]]
Output: 27
Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3. 1*1 + 4*2 + 6*3 = 27.
Example 3:

Input: nestedList = [0]
Output: 0
¬†

Constraints:

1 <= nestedList.length <= 50
The values of the integers in the nested list is in the range [-100, 100].
The maximum depth of any integer is less than or equal to 50.

```

- code
```python
# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger(object):
#    def __init__(self, value=None):
#        """
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        """
#
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def add(self, elem):
#        """
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        """
#
#    def setInteger(self, value):
#        """
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """
class Solution(object):
    def depthSum(self, nestedList):
        """
        :type nestedList: List[NestedInteger]
        :rtype: int
        """
        self.depth = 1
        def search(curNestedList):
            s = 0
            for i in range(len(curNestedList)):
                val = curNestedList[i]
                if val.isInteger():
                    s += val.getInteger() * self.depth
                else:
                    self.depth += 1
                    s += search(val.getList())
                    self.depth -= 1
            return s

        return search(nestedList)

```

#### 133. Clone Graph

- È¢òÁõÆ
```
Given a reference of a node in a connected undirected graph.

Return a deep copy (clone) of the graph.

Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.

class Node {
    public int val;
    public List<Node> neighbors;
}
 

Test case format:

For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.

An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.

The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.

 

Example 1:


Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]
Explanation: There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
Example 2:


Input: adjList = [[]]
Output: [[]]
Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
Example 3:

Input: adjList = []
Output: []
Explanation: This an empty graph, it does not have any nodes.
 

Constraints:

The number of nodes in the graph is in the range [0, 100].
1 <= Node.val <= 100
Node.val is unique for each node.
There are no repeated edges and no self-loops in the graph.
The Graph is connected and all nodes can be visited starting from the given node.
```

- dfsÈ¢òËß£

```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution(object):
    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        
        self.node_to_clone = dict()
        def search(node):
            if not node:
                return None
            if node in self.node_to_clone:
                return self.node_to_clone[node]
            
            clone = Node(node.val)
            self.node_to_clone[node] = clone
            for child in node.neighbors:
                clone.neighbors.append(search(child))
            return clone
        return search(node)

```

- bfsÈ¢òËß£

```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution(object):
    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if not node:
            return node
        copy = Node(node.val)
        d = deque()
        d.append([node, copy])
        visited = dict()
        visited[node] = copy
        while d:
            cur, copy = d.popleft()
            for child in cur.neighbors:
                if child not in visited:
                    child_copy = Node(child.val)
                    visited[child] = child_copy
                    d.append([child, child_copy])
                copy.neighbors.append(visited[child])
        return visited[node]

```


#### 227. Basic Calculator II

```
Given a string s which represents an expression, evaluate this expression and return its value. 

The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].

Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().

Example 1:

Input: s = "3+2*2"
Output: 7
Example 2:

Input: s = " 3/2 "
Output: 1
Example 3:

Input: s = " 3+5 / 2 "
Output: 5
```

- Áî®stackËß£ÂÜ≥
```python
class Solution(object):
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        """
        pre_mark = '+'
        val = 0
        res = []
        for i in range(len(s)):
            if s[i].isdigit():
                val = val * 10 + int(s[i])
            if (not s[i].isdigit() and s[i] != ' ') or i == len(s) - 1 :
                if pre_mark == '+':
                    res.append(val)
                elif pre_mark == '-':
                    res.append(-val)
                elif pre_mark == '*':
                    res[-1] *= val
                elif pre_mark == '/':
                    val_to_fix = 0
                    if res[-1] < 0 and (-res[-1]) % val > 0:
                        val_to_fix = 1
                    res[-1] /= val
                    res[-1] += val_to_fix
                pre_mark = s[i]
                val = 0
        return sum(res)
        
```

- ‰∏çÁî®stackÔºåÂõ†‰∏∫Âè™ÈúÄË¶ÅÁúãÊúÄËøëÁöÑ‰∏§‰∏™ÂÖÉÁ¥†Âç≥ÂèØ

```python
class Solution(object):
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        
        Input: s = "3+2*2"
        Output: 7
        
        l1=3
        l2=2*2
        
        2
        
        """
        pre_mark = '+'
        val = 0
        
        res = 0
        l1 = 0
        l2 = 0
        for i in range(len(s)):
            if s[i].isdigit():
                val = val * 10 + int(s[i])
            if (not s[i].isdigit() and s[i] != ' ') or i == len(s) - 1 :
                if pre_mark == '+':
                    res += l1
                    l1 = l2
                    l2 = val
                elif pre_mark == '-':
                    res += l1
                    l1 = l2
                    l2 = -val
                elif pre_mark == '*':
                    l2 *= val
                elif pre_mark == '/':
                    val_to_fix = 0
                    if l2 < 0 and (-l2) % val > 0:
                        val_to_fix = 1
                    l2 /= val
                    l2 += val_to_fix
                pre_mark = s[i]
                val = 0
        return res + l1 + l2
```
### Round2(coding)Ôºö‰∏§È¢ò

#### 65. Valid Number

```

A valid number can be split up into these components (in order):

A decimal number or an integer.
(Optional) An 'e' or 'E', followed by an integer.
A decimal number can be split up into these components (in order):

(Optional) A sign character (either '+' or '-').
One of the following formats:
One or more digits, followed by a dot '.'.
One or more digits, followed by a dot '.', followed by one or more digits.
A dot '.', followed by one or more digits.
An integer can be split up into these components (in order):

(Optional) A sign character (either '+' or '-').
One or more digits.
For example, all the following are valid numbers: ["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"], while the following are not valid numbers: ["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"].

Given a string s, return true if s is a valid number.

 

Example 1:

Input: s = "0"
Output: true
Example 2:

Input: s = "e"
Output: false
Example 3:

Input: s = "."
Output: false
```

```python
class Solution(object):

    def isValidFloat(self, val):
        val_split = val.split('.')
        if len(val_split) != 2:
            return False
        val_split = [_ for _ in val_split if _]
        if len(val_split) == 0:
            return False
        for tmp in val_split:
            if not tmp.isdigit():
                return False
        return True

    def isValidInt(self, val):
        # print('val:', val)
        if not val:
            # print('False')
            return False
        n = len(val)
        # print('val.isdigit():', val.isdigit())
        return val.isdigit()

        """
        "abc"
        "1a"
        "1e"
        "e3"
        "99e2.5"
        "--6"
        "-+3"
        "95a54e53"
        """
    def isNumber(self, s):
        """
        :type s: str
        :rtype: bool
        """

        """
        Â∞èÊï∞ÊàñËÄÖÊï¥Êï∞ + eÊàñËÄÖEÂÜçÂä†Êï¥Êï∞

        """
        s = s.replace(' ', '')
        if not s:
            return False
        if s == '.':
            return False
        s = s.lower()
        if s.find('e') == -1:
            if s[0] in ['+', '-']:
                return self.isValidInt(s[1:]) or self.isValidFloat(s[1:])
            else:
                return self.isValidInt(s) or self.isValidFloat(s)
        else:
            ls = s.split('e')
            if len(ls) != 2:
                return False
            ls = [_ for _ in ls if _]
            if len(ls) != 2:
                return False
            if ls[1][0] in ['+', '-']:
                if not self.isValidInt(ls[1][1:]):
                    return False
            else:
                if not self.isValidInt(ls[1]):
                    return False
            if ls[0][0] in ['+', '-']:
                if ls[0][1:]:
                    return self.isValidInt(ls[0][1:]) or self.isValidFloat(ls[0][1:])
                else:
                    return False
            else:
                return self.isValidInt(ls[0]) or self.isValidFloat(ls[0])

```

#### 670. Maximum Swap

```
You are given an integer num. You can swap two digits at most once to get the maximum valued number.

Return the maximum valued number you can get.

 

Example 1:

Input: num = 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.
Example 2:

Input: num = 9973
Output: 9973
Explanation: No swap.

```

```python
class Solution(object):
    def maximumSwap(self, num):
        """
        :type num: int
        :rtype: int
        """

        """
        27

        max_val_index=1
        max_val = 7
        left_index=2
             
           l  
        [2,7,3,6]

        È¢òËß£Ôºö‰ªéÂè≥Âà∞Â∑¶ÈÅçÂéÜÔºåÊâæÂà∞ÊúÄÂ∑¶ËæπÊòØÂê¶Â≠òÂú®‰∏Ä‰∏™Êï∞ÔºåÂ∞è‰∫éÂè≥ËæπÁöÑÊúÄÂ§ßÂÄºÔºåÂ¶ÇÊûúÊúâÔºåÂàôÊääÂè≥ËæπÁöÑÊúÄÂ§ßÂÄº‰∏éÊúÄÂ∑¶ËæπÁöÑËøô‰∏™ÂÄºÊõøÊç¢„ÄÇ
        """
        cache = []
        num = list(str(num))
        n = len(num)
        left_index_to_swap_index = dict()
        max_val_index = n - 1
        max_val = num[n-1]
        left_index = -1
        for i in range(n-2, -1, -1):
            if num[i] > max_val:
                max_val = num[i]
                max_val_index = i
            elif num[i] < max_val:
                left_index = i
                left_index_to_swap_index[left_index] = max_val_index
            # print('max_val_index:', max_val_index)
            # print('left_index:', left_index)
            # print("left_index_to_swap_index:", left_index_to_swap_index)
        
        if left_index != -1 and left_index < left_index_to_swap_index[left_index]:
            swap_index = left_index_to_swap_index[left_index]
            num[left_index], num[swap_index] = num[swap_index], num[left_index]
        
        return int(''.join(num))

```

### Round3(ML)


### Round3(BQ)


# MetaÈ´òÈ¢ë
## ÂàÜÁ±ª‰∏éÊÄªÁªì

### ÊÄªÁªì


### stack

#### 1249. Minimum Remove to Make Valid Parentheses

```
Given a string s of '(' , ')' and lowercase English characters.

Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:

It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
 

Example 1:

Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
Example 2:

Input: s = "a)b(c)d"
Output: "ab(c)d"
```

```python
class Solution(object):
    def minRemoveToMakeValid(self, s):
        """
        :type s: str
        :rtype: str

        "abc

        left=1
         right=

        a)b(c)d

        ((abc(d

        ['lee', [''], t, ['']]

        """

        left = 0
        left_index = []
        right = 0

        remove_index_set = set()

        for i in range(len(s)):
            if s[i] == '(':
                left_index.append(i)
                left += 1
            elif s[i] == ')':
                if left <= 0:
                    remove_index_set.add(i)
                else:
                    left -= 1
                    left_index.pop()
                # print("left_index:", left_index)

        while left_index:
            remove_index_set.add(left_index.pop())

        res = []
        for i in range(len(s)):
            if i not in remove_index_set:
                res.append(s[i])

        return ''.join(res)
        
```

## È´òÈ¢ëÈ¢ò

#### 1249. Minimum Remove to Make Valid Parentheses

```
Given a string s of '(' , ')' and lowercase English characters.

Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:

It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
 

Example 1:

Input: s = "lee(t(c)o)de)"
Output: "lee(t(c)o)de"
Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.
Example 2:

Input: s = "a)b(c)d"
Output: "ab(c)d"
```

```python
class Solution(object):
    def minRemoveToMakeValid(self, s):
        """
        :type s: str
        :rtype: str

        "abc

        left=1
         right=

        a)b(c)d

        ((abc(d

        ['lee', [''], t, ['']]

        """

        left = 0
        left_index = []
        right = 0

        remove_index_set = set()

        for i in range(len(s)):
            if s[i] == '(':
                left_index.append(i)
                left += 1
            elif s[i] == ')':
                if left <= 0:
                    remove_index_set.add(i)
                else:
                    left -= 1
                    left_index.pop()
                # print("left_index:", left_index)

        while left_index:
            remove_index_set.add(left_index.pop())

        res = []
        for i in range(len(s)):
            if i not in remove_index_set:
                res.append(s[i])

        return ''.join(res)
        
```

#### 680. Valid Palindrome II

```
Given a string s, return true if the s can be palindrome after deleting at most one character from it.

Example 1:

Input: s = "aba"
Output: true
Example 2:

Input: s = "abca"
Output: true
Explanation: You could delete the character 'c'.
Example 3:

Input: s = "abc"
Output: false
```

```python

class Solution(object):
    def validPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """


        def is_valid_palindrom_between_left_and_right(l, r, delete_flag):
            while l <= r:
                if l == r:
                    return True
                if s[l] == s[r]:
                    if r - l <= 1:
                        return True
                    l += 1
                    r -= 1
                else:
                    if not delete_flag:
                        return is_valid_palindrom_between_left_and_right(l, r-1, True) or \
                            is_valid_palindrom_between_left_and_right(l+1, r, True)
                    else:
                        return False
            return False


        return is_valid_palindrom_between_left_and_right(0, len(s) - 1, False)
                

```
#### 953. Verifying an Alien Dictionary


```
In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.

Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.

 

Example 1:

Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
Output: true
Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.
Example 2:

Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
Output: false
Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.
```


```python

class Solution(object):
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """

        def slower_than(word1, word2, letter_start_index):
            """return True if word1 < word2"""

            for i in range(min(len(word1), len(word2))):
                letter1, letter2 = word1[i], word2[i]
                l1_index = ord(letter1) - ord('a')
                l2_index = ord(letter2) - ord('a')
                # print(letter1, letter2, l1_index, l2_index)
                if letter_start_index[l1_index] > letter_start_index[l2_index]:
                    return False
                elif letter_start_index[l1_index] < letter_start_index[l2_index]:
                    return True
            if len(word1) > len(word2):
                return False            
            return True


        letter_start_index = [float('inf')] * 26
        for i in range(len(order)):
            letter = order[i]
            if letter not in letter_start_index:
                letter_start_index[ord(letter) - ord('a')] = i

        for i in range(len(words) - 1):
            if not slower_than(words[i], words[i+1], letter_start_index):
                return False
        
        return True
```


#### 301. Remove Invalid Parentheses

```

Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.

Return all the possible results. You may return the answer in any order.

 

Example 1:

Input: s = "()())()"
Output: ["(())()","()()()"]
Example 2:

Input: s = "(a)())()"
Output: ["(a())()","(a)()()"]
Example 3:

Input: s = ")("
Output: [""]
```


```python
class Solution(object):
    def removeInvalidParentheses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """

        def is_valid(s1):
            if not s1:
                return True
            l, r = 0, 0
            for i in range(len(s1)):
                if s1[i] == '(':
                    l += 1
                elif s1[i] == ')':
                    if l <= 0:
                        return False
                    else:
                        l -= 1
            return l == r

        res = []
        def search(s1, l, r, start):
            # print("s1, l, r, start:", s1, l, r, start)
            if l == 0 and r == 0 and is_valid(s1):
                res.append(s1)
                # print('res:', res, 's1:' ,s1)
                return
            if r > 0:
                for i in range(start, len(s1)):
                    if i != start and s1[i] == s1[i-1]:
                        continue
                    if s1[i] == ')':
                        search(s1[:i]+s1[i+1:], l, r - 1, i)# ÂáèÂéªÁ¨¨i‰∏™ÂÖÉÁ¥†‰∫ÜÔºå‰∏ã‰∏Ä‰∏™ËøòÊòØ‰ªéiÂºÄÂßãÂà†
            elif l > 0:
                for i in range(start, len(s1)):
                    if i != start and s1[i] == s1[i-1]:
                        continue
                    if s1[i] == '(':
                        search(s1[:i]+s1[i+1:], l - 1, r, i)

        n = len(s)
        l, r = 0, 0
        for i in range(n):
            if s[i] == '(':
                l += 1
            elif s[i] == ')':
                if l <= 0:
                    r += 1
                else:
                    l -= 1

        search(s, l, r, 0)
        return res
```
#### 973. K Closest Points to Origin

```
Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).

The distance between two points on the X-Y plane is the Euclidean distance (i.e., ‚àö(x1 - x2)2 + (y1 - y2)2).

You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).

¬†

Example 1:


Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].
Example 2:

Input: points = [[3,3],[5,-1],[-2,4]], k = 2
Output: [[3,3],[-2,4]]
Explanation: The answer [[-2,4],[3,3]] would also be accepted.

```

```python
class Solution(object):
    def kClosest(self, points, k):
        """
        :type points: List[List[int]]
        :type k: int
        :rtype: List[List[int]]
        """
        def get_dis(x1, y1):
            return x1 ** 2 + y1 ** 2

        dis = [[get_dis(points[i][0], points[i][1]), i] for i in range(len(points))]

        def find_k_closest_pointer(l, r, res_k):
            k1 = l - 1
            for i in range(l, r):
                if dis[i][0] <= dis[r][0]:
                    k1 += 1
                    dis[i], dis[k1] = dis[k1], dis[i]
            k1 += 1
            dis[r], dis[k1] = dis[k1], dis[r]
            if k1 - l + 1 == res_k:
                return [points[dis[i][1]] for i in range(k)]
            if res_k > k1 - l + 1:
                return find_k_closest_pointer(k1 + 1, r, res_k - (k1 - l + 1))
            else:
                return find_k_closest_pointer(l, k1 - 1, res_k)

        return find_k_closest_pointer(0, len(dis) - 1, k)
        
```

#### 67. Add Binary

```
Example 1:

Input: a = "11", b = "1"
Output: "100"
Example 2:

Input: a = "1010", b = "1011"
Output: "10101"
```

```python
class Solution(object):
    def addBinary(self, a, b):
        """
        :type a: str
        :type b: str
        :rtype: str
        """
        res = []
        add = 0
        m, n = len(a), len(b)
        for i in range(max(m, n)):
            if i < m:
                x = a[m - i - 1]
            else:
                x = 0
            if i < n:
                y = b[n - i - 1]
            else:
                y = 0
            s = int(x) + int(y) + add
            add = s // 2
            res.append(s % 2)
        if add:
            res.append(add)
        return ''.join([str(_) for _ in res[::-1]])
```

<<<<<<< HEAD
#### 273. Integer to English Words

"""
one two three four five six seven eight nigh? 
ten eleven twelve thirteen fourteen fifteen? sixteen seventeen eighteen nighteen
twenty thirty fourty fifty? sixty seventy eighty nighty
hundred
thouthand million billion

nigh -> nine
nighteen -> nineteen
fourty -> fouty
fifty -> fifty
"""

```python

class Solution(object):
    def numberToWords(self, num):
        """
        :type num: int
        :rtype: str
        """
        if num == 0:
            return "Zero"
        ones = ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
        teens = ["Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"]
        tens = ["Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"]
        thousands = [" Thousand", " Million", " Billion"]
        def search(num):
            s = ""
            # 1. if num biger than base, use recursion to get the result and return result,
            # be careful when mode == 0
            for i, base in enumerate([1000000000, 1000000, 1000]):
                if num >= base:
                    s += self.numberToWords(num // base) + thousands[2 - i]
                    if num % base != 0:
                        s += " " + self.numberToWords(num % base)
                    return s
            # 2. if num slower than 1000, check if it at range in [0, 10, 20, 100]
            if num < 1000:
                if num >= 100:
                    if num % 100 == 0:
                        s += self.numberToWords(num // 100) + " Hundred"
                    else:
                        s += self.numberToWords(num // 100) + " Hundred " + self.numberToWords(num % 100)
                elif num >= 20:
                    i = num // 10
                    if num % 10 == 0:
                        s += tens[i - 2]
                    else:
                        s += tens[i - 2] + " " + ones[num % 10 - 1]
                elif num >= 10:
                    s += teens[num - 10]
                else:
                    s += ones[num - 1]
            return s
        return search(num)

        
```

#### 560 Â≠êÊï∞ÁªÑÂíå‰∏∫kÁöÑ‰∏™Êï∞

```python

class Solution(object):
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        pre_sum_cnt = dict()
        pre_sum_cnt[0] = 1
        cur_sum = 0
        cnt = 0
        for num in nums:
            cur_sum += num
            diff = cur_sum - k
            if diff in pre_sum_cnt:
                cnt += pre_sum_cnt[diff]
            if cur_sum not in pre_sum_cnt:
                pre_sum_cnt[cur_sum] = 0
            pre_sum_cnt[cur_sum] += 1
        return cnt
```

#### 314. Binary Tree Vertical Order Traversal

```
Given the root of a binary tree, return the vertical order traversal of its nodes' values. (i.e., from top to bottom, column by column).

If two nodes are in the same row and column, the order should be from left to right.

¬†

Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: [[9],[3,15],[20],[7]]
Example 2:


Input: root = [3,9,8,4,0,1,7]
Output: [[4],[9],[3,0,1],[8],[7]]
Example 3:


Input: root = [3,9,8,4,0,1,7,null,null,null,2,5]
Output: [[4],[9,5],[3,0,1],[8,2],[7]]

```

```python

=======

#### todolist [273, 301, 314, 125, 238, 938, 56, 215, 1762, 1570, 31, 199]

#### todolist [528, 173, 415, 1, 29, 297, 278, 236, 253, 621, 91, 88, 543, 71, 50, 124, 10, 1650, 227, 138, 426, 133, 15, 158, 1428]

#### 528. Random Pick with Weight

```python
# You are given a 0-indexed array of positive integers w where w[i] describes 
# the weight of the i·µó ∞ index. 
# 
#  You need to implement the function pickIndex(), which randomly picks an 
# index in the range [0, w.length - 1] (inclusive) and returns it. The probability of 
# picking an index i is w[i] / sum(w). 
# 
#  
#  For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3)
#  = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.7
# 5 (i.e., 75%). 
#  
# 
#  
#  Example 1: 
# 
#  
# Input
# ["Solution","pickIndex"]
# [[[1]],[]]
# Output
# [null,0]
# 
# Explanation
# Solution solution = new Solution([1]);
# solution.pickIndex(); // return 0. The only option is to return 0 since there 
# is only one element in w.
#  
# 
#  Example 2: 
# 
#  
# Input
# ["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
# [[[1,3]],[],[],[],[],[]]
# Output
# [null,1,1,1,1,0]
# 
# Explanation
# Solution solution = new Solution([1, 3]);
# solution.pickIndex(); // return 1. It is returning the second element (index =
#  1) that has a probability of 3/4.
# solution.pickIndex(); // return 1
# solution.pickIndex(); // return 1
# solution.pickIndex(); // return 1
# solution.pickIndex(); // return 0. It is returning the first element (index = 
# 0) that has a probability of 1/4.
# 
# Since this is a randomization problem, multiple answers are allowed.
# All of the following outputs can be considered correct:
# [null,1,1,1,1,0]
# [null,1,1,1,1,1]
# [null,1,1,1,0,0]
# [null,1,1,1,0,1]
# [null,1,0,1,0,0]
# ......
# and so on.
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= w.length <= 10‚Å¥ 
#  1 <= w[i] <= 10‚Åµ 
#  pickIndex will be called at most 10‚Å¥ times. 
#  
# 
#  Related Topics Êï∞Â≠¶ ‰∫åÂàÜÊü•Êâæ ÂâçÁºÄÂíå ÈöèÊú∫Âåñ üëç 271 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
import random


class Solution(object):

    def __init__(self, w):
        """
        :type w: List[int]
        """
        s = float(sum(w))
        for i in range(len(w)):
            if i == 0:
                w[i] = w[i] / s
            else:
                w[i] = w[i-1] + w[i] / s
        self.w = w

    def pickIndex(self):
        """
        :rtype: int
        """
        val = random.random()
        if val <= self.w[0]:
            return 0
        l, r = 0, len(self.w) - 1
        while l <= r:
            m = l + r >> 1
            if self.w[m-1] < val <= self.w[m]:
                return m
            elif val > self.w[m]:
                l = m + 1
            else:
                r = m - 1



# Your Solution object will be instantiated and called as such:
# obj = Solution(w)
# param_1 = obj.pickIndex()
# leetcode submit region end(Prohibit modification and deletion)
```

#### 173. Binary Search Tree Iterator

```python
# Implement the BSTIterator class that represents an iterator over the in-order 
# traversal of a binary search tree (BST): 
# 
#  
#  BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. 
# The root of the BST is given as part of the constructor. The pointer should be 
# initialized to a non-existent number smaller than any element in the BST. 
#  boolean hasNext() Returns true if there exists a number in the traversal to 
# the right of the pointer, otherwise returns false. 
#  int next() Moves the pointer to the right, then returns the number at the 
# pointer. 
#  
# 
#  Notice that by initializing the pointer to a non-existent smallest number, 
# the first call to next() will return the smallest element in the BST. 
# 
#  You may assume that next() calls will always be valid. That is, there will 
# be at least a next number in the in-order traversal when next() is called. 
# 
#  
#  Example 1: 
#  
#  
# Input
# ["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", 
# "hasNext", "next", "hasNext"]
# [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
# Output
# [null, 3, 7, true, 9, true, 15, true, 20, false]
#  
# 
# Explanation
# BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
# bSTIterator.next(); // return 3
# bSTIterator.next(); // return 7
# bSTIterator.hasNext(); // return True
# bSTIterator.next(); // return 9
# bSTIterator.hasNext(); // return True
# bSTIterator.next(); // return 15
# bSTIterator.hasNext(); // return True
# bSTIterator.next(); // return 20
# bSTIterator.hasNext(); // return False
# 
# 
#  
#  Constraints: 
# 
#  
#  The number of nodes in the tree is in the range [1, 10‚Åµ]. 
#  0 <= Node.val <= 10‚Å∂ 
#  At most 10‚Åµ calls will be made to hasNext, and next. 
#  
# 
#  
#  Follow up: 
# 
#  
#  Could you implement next() and hasNext() to run in average O(1) time and use 
# O(h) memory, where h is the height of the tree? 
#  
# 
#  Related Topics Ê†à Ê†ë ËÆæËÆ° ‰∫åÂèâÊêúÁ¥¢Ê†ë ‰∫åÂèâÊ†ë Ëø≠‰ª£Âô® üëç 648 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
>>>>>>> a6458e09e981973146b15bab82b079e0ee0762ad
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
<<<<<<< HEAD
class Solution(object):
    def verticalOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        d = deque()
        d.append([root, 0])
        loc_to_node_list = defaultdict(list)
        min_loc = 0
        while d:
            cur, cur_loc = d.popleft()
            loc_to_node_list[cur_loc].append(cur.val)
            if cur.left:
                d.append([cur.left, cur_loc - 1])
            if cur.right:
                d.append([cur.right, cur_loc + 1])
            min_loc = min(cur_loc, min_loc)
        res = []
        for loc in range(min_loc, min_loc + len(loc_to_node_list)):
            res.append(loc_to_node_list[loc])
        return res
```
#### 125. Valid Palindrome

```
A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

 

Example 1:

Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
Example 2:

Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

```python
class Solution(object):
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        s_list = []
        for i in range(len(s)):
            if 'a'<=s[i]<='z' or 'A'<=s[i]<='Z' or '0'<=s[i]<='9':
                s_list.append(s[i].lower())
        # print('s_list:', s_list)
        l, r = 0, len(s_list) - 1
        while l < r:
            if s_list[l] == s_list[r]:
                l += 1
                r -= 1
            else:
                return False
        return True
```

#### 238. Product of Array Except Self

```
Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in¬†O(n)¬†time and without using the division operation.

¬†

Example 1:

Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Example 2:

Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
```

```python
class Solution(object):
    def productExceptSelf(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """

        n = len(nums)
        l = [1] * n
        r = [1] * n

        for i in range(n):
            if i == 0:
                l[i] = nums[i]
                r[n-1-i] = nums[n-1-i]
            else:
                l[i] = l[i-1] * nums[i]
                r[n-1-i] = r[n-i] * nums[n-i-1]

        p = [0] * n
        for i in range(n):
            if i == 0:
                p[i] = r[i+1]
            elif i == n - 1:
                p[i] = l[i-1]
            else:
                p[i] = l[i-1] * r[i+1]
        return p

```


#### 938. Range Sum of BST

```
Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].


Example 1:


Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
Output: 32
Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
Example 2:


Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
Output: 23
Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.

```

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def rangeSumBST(self, root, low, high):
        """
        :type root: TreeNode
        :type low: int
        :type high: int
        :rtype: int
        """
        self.sum = 0
        def search(node):
            if not node:
                return
            if node.val < low:
                search(node.right)
            elif node.val > high:
                search(node.left)
            else:
                self.sum += node.val
                search(node.left)
                search(node.right)
        search(root)
        return self.sum

```

#### 1762. Buildings With an Ocean View

```
There are n buildings in a line. You are given an integer array heights of size n that represents the heights of the buildings in the line.

The ocean is to the right of the buildings. A building has an ocean view if the building can see the ocean without obstructions. Formally, a building has an ocean view if all the buildings to its right have a smaller height.

Return a list of indices (0-indexed) of buildings that have an ocean view, sorted in increasing order.

¬†

Example 1:

Input: heights = [4,2,3,1]
Output: [0,2,3]
Explanation: Building 1 (0-indexed) does not have an ocean view because building 2 is taller.
Example 2:

Input: heights = [4,3,2,1]
Output: [0,1,2,3]
Explanation: All the buildings have an ocean view.
Example 3:

Input: heights = [1,3,2,4]
Output: [3]
Explanation: Only building 3 has an ocean view.

```

```python
class Solution(object):
    def findBuildings(self, h):
        """
        :type heights: List[int]
        :rtype: List[int]

        h=[2,2]
        m=2
        1
        0
        """
        n = len(h)
        m = h[-1] - 1
        tmp = []
        for i in range(n-1, -1, -1):
            if h[i] > m:
                tmp.append(i)
                m = h[i]
        res = []
        while tmp:
            res.append(tmp.pop())
        return res

```


#### 215. Kth Largest Element in an Array

```
Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

You must solve it in O(n) time complexity.

¬†

Example 1:

Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Example 2:

Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
```

```python
class Solution(object):
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """

        def search(l, r, k):
            mid = l + r >> 1
            nums[mid], nums[r] = nums[r], nums[mid]
            k1, k2 = l - 1, l
            while k2 < r:
                if nums[k2] > nums[r]:
                    k1 += 1
                    nums[k1], nums[k2] = nums[k2], nums[k1]
                k2 += 1
            k1 += 1
            nums[k1], nums[r] = nums[r], nums[k1]
            if k1 - l + 1 == k:
                return nums[k1]
            elif k1 - l + 1 > k:
                return search(l, k1 - 1, k)
            else:
                return search(k1 + 1, r, k - (k1 - l + 1))

        return search(0, len(nums) - 1, k)
=======
class BSTIterator(object):
    """
    ÊÄùË∑ØÔºö‰∏≠Â∫èÈÅçÂéÜ
    1. ÂÖàÂ∞ÜÂΩìÂâçËäÇÁÇπÁöÑÊâÄÊúâÂ∑¶Â≠êÊ†ëÂéãÂÖ•Ê†àÔºåÂéãÂà∞Ê≤°Êúâ‰∏∫Ê≠¢
    2. Â∞ÜÊúÄÂêé‰∏Ä‰∏™ÂéãÂÖ•ÁöÑËäÇÁÇπÂºπÂá∫ÔºàÊ†àÈ°∂ÂÖÉÁ¥†ÔºâÔºåÂä†ÂÖ•Á≠îÊ°à
    3. Â∞ÜÂΩìÂâçÂºπÂá∫ÁöÑËäÇÁÇπ‰Ωú‰∏∫ÂΩìÂâçËäÇÁÇπÔºåÈáçÂ§çÊ≠•È™§‰∏Ä
    """

    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.head = root
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def next(self):
        """
        :rtype: int
        """
        cur = self.stack.pop()
        root = cur.right
        while root:
            self.stack.append(root)
            root = root.left
        return cur.val
        

    def hasNext(self):
        """
        :rtype: bool
        """
        return len(self.stack) > 0
        


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
# leetcode submit region end(Prohibit modification and deletion)


```

#### 415. Add Strings


```pyhton
# Given two non-negative integers, num1 and num2 represented as string, return 
# the sum of num1 and num2 as a string. 
# 
#  You must solve the problem without using any built-in library for handling 
# large integers (such as BigInteger). You must also not convert the inputs to 
# integers directly. 
# 
#  
#  Example 1: 
# 
#  
# Input: num1 = "11", num2 = "123"
# Output: "134"
#  
# 
#  Example 2: 
# 
#  
# Input: num1 = "456", num2 = "77"
# Output: "533"
#  
# 
#  Example 3: 
# 
#  
# Input: num1 = "0", num2 = "0"
# Output: "0"
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= num1.length, num2.length <= 10‚Å¥ 
#  num1 and num2 consist of only digits. 
#  num1 and num2 don't have any leading zeros except for the zero itself. 
#  
# 
#  Related Topics Êï∞Â≠¶ Â≠óÁ¨¶‰∏≤ Ê®°Êãü üëç 625 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def addStrings(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        m, n = len(num1), len(num2)
        add = 0
        k1, k2 = m - 1, n - 1
        res = []
        while k1 >= 0 or k2 >= 0:
            a = 0 if k1 < 0 else int(num1[k1])
            b = 0 if k2 < 0 else int(num2[k2])
            k1 -= 1
            k2 -= 1
            cur = a + b + add
            add = cur // 10
            cur = cur % 10
            res.append(str(cur))
        if add:
            res.append(str(add))
        return ''.join(res[::-1])


# leetcode submit region end(Prohibit modification and deletion)


```


#### 29 Divide Two Integers

```python
# Given two integers dividend and divisor, divide two integers without using 
# multiplication, division, and mod operator. 
# 
#  The integer division should truncate toward zero, which means losing its 
# fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be 
# truncated to -2. 
# 
#  Return the quotient after dividing dividend by divisor. 
# 
#  Note: Assume we are dealing with an environment that could only store 
# integers within the 32-bit signed integer range: [‚àí2¬≥¬π, 2¬≥¬π ‚àí 1]. For this problem, if 
# the quotient is strictly greater than 2¬≥¬π - 1, then return 2¬≥¬π - 1, and if the 
# quotient is strictly less than -2¬≥¬π, then return -2¬≥¬π. 
# 
#  
#  Example 1: 
# 
#  
# Input: dividend = 10, divisor = 3
# Output: 3
# Explanation: 10/3 = 3.33333.. which is truncated to 3.
#  
# 
#  Example 2: 
# 
#  
# Input: dividend = 7, divisor = -3
# Output: -2
# Explanation: 7/-3 = -2.33333.. which is truncated to -2.
#  
# 
#  
#  Constraints: 
# 
#  
#  -2¬≥¬π <= dividend, divisor <= 2¬≥¬π - 1 
#  divisor != 0 
#  
# 
#  Related Topics ‰ΩçËøêÁÆó Êï∞Â≠¶ üëç 991 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def divide(self, dividend, divisor):
        """
        :type dividend: int
        :type divisor: int
        :rtype: int
        10 / 3
        2^0, 2^1, 2^2
        3, 3+3, 3+3+3+3,
        base = 3
        cnt = 1
        """
        neg_flag = True if ((dividend > 0 and divisor <0) or (dividend < 0 and divisor > 0)) else False
        dividend = -dividend if dividend < 0 else dividend
        divisor = -divisor if divisor < 0 else divisor
        res = 0
        while dividend >= divisor:
            base = divisor
            cnt = 1
            while dividend - base > base:
                base += base
                cnt += cnt
            dividend -= base
            res += cnt
        if neg_flag:
            res = -res
        max_int = (1 << 31) - 1
        min_int = -(1 << 31)
        if res > max_int:
            return max_int
        if res < min_int:
            return min_int
        return res



# leetcode submit region end(Prohibit modification and deletion)


```

#### 297 Serialize and Deserialize Binary Tree

```python
# Serialization is the process of converting a data structure or object into a 
# sequence of bits so that it can be stored in a file or memory buffer, or 
# transmitted across a network connection link to be reconstructed later in the same or 
# another computer environment. 
# 
#  Design an algorithm to serialize and deserialize a binary tree. There is no 
# restriction on how your serialization/deserialization algorithm should work. You 
# just need to ensure that a binary tree can be serialized to a string and this 
# string can be deserialized to the original tree structure. 
# 
#  Clarification: The input/output format is the same as how LeetCode 
# serializes a binary tree. You do not necessarily need to follow this format, so please be 
# creative and come up with different approaches yourself. 
# 
#  
#  Example 1: 
#  
#  
# Input: root = [1,2,3,null,null,4,5]
# Output: [1,2,3,null,null,4,5]
#  
# 
#  Example 2: 
# 
#  
# Input: root = []
# Output: []
#  
# 
#  
#  Constraints: 
# 
#  
#  The number of nodes in the tree is in the range [0, 10‚Å¥]. 
#  -1000 <= Node.val <= 1000 
#  
# 
#  Related Topics Ê†ë Ê∑±Â∫¶‰ºòÂÖàÊêúÁ¥¢ ÂπøÂ∫¶‰ºòÂÖàÊêúÁ¥¢ ËÆæËÆ° Â≠óÁ¨¶‰∏≤ ‰∫åÂèâÊ†ë üëç 986 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ""
        path = []
        d = deque()
        d.append(root)
        while d:
            cur = d.popleft()
            if cur:
                path.append(str(cur.val))
                d.append(cur.left)
                d.append(cur.right)
            else:
                path.append("#")
        res = ','.join(path)
        # print(res)
        return res

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return None
        data = data.split(',')
        n = len(data)
        i = 0
        root = TreeNode(data[i])
        i += 1
        d = deque()
        d.append(root)
        while d:
            cur = d.popleft()
            if data[i] != '#':
                left = TreeNode(data[i])
                i += 1
                cur.left = left
                d.append(left)
            else:
                i += 1
            if data[i] != '#':
                right = TreeNode(data[i])
                i += 1
                cur.right = right
                d.append(right)
            else:
                i += 1
        # 1,2,3,null,null,4,5
        return root



        

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
# leetcode submit region end(Prohibit modification and deletion)


```

#### 278 First Bad Version

```python
# You are a product manager and currently leading a team to develop a new 
# product. Unfortunately, the latest version of your product fails the quality check. 
# Since each version is developed based on the previous version, all the versions 
# after a bad version are also bad. 
# 
#  Suppose you have n versions [1, 2, ..., n] and you want to find out the 
# first bad one, which causes all the following ones to be bad. 
# 
#  You are given an API bool isBadVersion(version) which returns whether 
# version is bad. Implement a function to find the first bad version. You should 
# minimize the number of calls to the API. 
# 
#  
#  Example 1: 
# 
#  
# Input: n = 5, bad = 4
# Output: 4
# Explanation:
# call isBadVersion(3) -> false
# call isBadVersion(5)¬†-> true
# call isBadVersion(4)¬†-> true
# Then 4 is the first bad version.
#  
# 
#  Example 2: 
# 
#  
# Input: n = 1, bad = 1
# Output: 1
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= bad <= n <= 2¬≥¬π - 1 
#  
# 
#  Related Topics ‰∫åÂàÜÊü•Êâæ ‰∫§‰∫í üëç 809 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
# The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution(object):
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """

        l, r = 1, n
        cand = l
        while l <= r:
            mid = l + r >> 1
            if isBadVersion(mid):
                cand = mid
                r = mid - 1
            else:
                l = mid + 1
        return cand
# leetcode submit region end(Prohibit modification and deletion)
>>>>>>> a6458e09e981973146b15bab82b079e0ee0762ad


```

<<<<<<< HEAD

#### 199. Binary Tree Right Side View

```
Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

¬†

Example 1:


Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
Example 2:

Input: root = [1,null,3]
Output: [1,3]
Example 3:

Input: root = []
Output: []
```

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        exist_layer = set()
        def dfs(root, layer):
            if not root:
                return
            if layer not in exist_layer:
                exist_layer.add(layer)
                res.append(root.val)
            dfs(root.right, layer + 1)
            dfs(root.left, layer + 1)
        dfs(root, 0)
        return res
```

#### 31. Next Permutation

```
A permutation of an array of integers is an arrangement of its members into a sequence or linear order.

For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].
The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

For example, the next permutation of arr = [1,2,3] is [1,3,2].
Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.
Given an array of integers nums, find the next permutation of nums.

The replacement must be in place and use only constant extra memory.

¬†

Example 1:

Input: nums = [1,2,3]
Output: [1,3,2]
Example 2:

Input: nums = [3,2,1]
Output: [1,2,3]
Example 3:

Input: nums = [1,1,5]
Output: [1,5,1]
```

```python
class Solution(object):
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """


        """

        l
           r
        3654321

        4654321
        """

        n = len(nums)
        if n == 1:
            return
        i = n - 2
        find = False
        while i >= 0:
            if nums[i] < nums[i+1]:
                find = True
                break
            i -= 1
        
        if not find:
            nums.sort()
            return
        

        def find_first_index_bigger_than_target(target, l, r):
            """find target in num at range [l, r]"""
            cand = l
            while l <= r:
                m = l + r >> 1
                # print(target, l, r, m, nums[m])
                if nums[m] > target:
                    cand = m
                    l = m + 1
                elif nums[m] < target:
                    r = m - 1
                else:
                    r = m - 1
            return cand

        first_index = find_first_index_bigger_than_target(nums[i], i+1, len(nums) - 1)
        nums[i], nums[first_index] = nums[first_index], nums[i]
        # print(nums)
        l, r = i + 1, len(nums) - 1
        while l < r:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r -= 1
        
        return
```

#### 56. Merge Intervals
```
Given an array¬†of intervals¬†where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

¬†

Example 1:

Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
Example 2:

Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

```python
class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        time: O(nlogn)
        space:O(logn)
        """
        intervals.sort(key = lambda x:[x[0], -x[1]])
        res = []
        for i in range(len(intervals)):
            if not res:
                res.append(intervals[i])
            else:
                if intervals[i][0] > res[-1][1]:
                    res.append(intervals[i])
                else:
                    res[-1][1] = max(res[-1][1], intervals[i][1])
        return res

```

#### 1570. Dot Product of Two Sparse Vectors
```
Given two sparse vectors, compute their dot product.

Implement class SparseVector:

SparseVector(nums)¬†Initializes the object with the vector nums
dotProduct(vec)¬†Compute the dot product between the instance of SparseVector and vec
A sparse vector is a vector that has mostly zero values, you should store the sparse vector¬†efficiently and compute the dot product between two SparseVector.

Follow up:¬†What if only one of the vectors is sparse?

¬†

Example 1:

Input: nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]
Output: 8
Explanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
v1.dotProduct(v2) = 1*0 + 0*3 + 0*0 + 2*4 + 3*0 = 8
Example 2:

Input: nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2]
Output: 0
Explanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
v1.dotProduct(v2) = 0*0 + 1*0 + 0*0 + 0*0 + 0*2 = 0
Example 3:

Input: nums1 = [0,1,0,0,2,0,0], nums2 = [1,0,0,0,3,0,4]
Output: 6
```

```python
class SparseVector:
    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        data = list()
        for i, num in enumerate(nums):
            if num != 0:
                data.append([i, num])
        self.data = data
        

    # Return the dotProduct of two sparse vectors
    def dotProduct(self, vec):
        """
        :type vec: 'SparseVector'
        :rtype: int
        """
        s = 0
        m, n = len(self.data), len(vec.data)
        k1, k2 = 0, 0
        while k1 < m and k2 < n:
            if self.data[k1][0] == vec.data[k2][0]:
                s += self.data[k1][1] * vec.data[k2][1]
                k1 += 1
                k2 += 1
            elif self.data[k1][0] > vec.data[k2][0]:
                k2 += 1
            else:
                k1 += 1
        return s
        

# Your SparseVector object will be instantiated and called as such:
# v1 = SparseVector(nums1)
# v2 = SparseVector(nums2)
# ans = v1.dotProduct(v2)
```

=======
#### 236 Lowest Common Ancestor of a Binary Tree

```python
# Given a binary tree, find the lowest common ancestor (LCA) of two given nodes 
# in the tree. 
# 
#  According to the definition of LCA on Wikipedia: ‚ÄúThe lowest common ancestor 
# is defined between two nodes p and q as the lowest node in T that has both p 
# and q as descendants (where we allow a node to be a descendant of itself).‚Äù 
# 
#  
#  Example 1: 
#  
#  
# Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
# Output: 3
# Explanation: The LCA of nodes 5 and 1 is 3.
#  
# 
#  Example 2: 
#  
#  
# Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
# Output: 5
# Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant 
# of itself according to the LCA definition.
#  
# 
#  Example 3: 
# 
#  
# Input: root = [1,2], p = 1, q = 2
# Output: 1
#  
# 
#  
#  Constraints: 
# 
#  
#  The number of nodes in the tree is in the range [2, 10‚Åµ]. 
#  -10‚Åπ <= Node.val <= 10‚Åπ 
#  All Node.val are unique. 
#  p != q 
#  p and q will exist in the tree. 
#  
# 
#  Related Topics Ê†ë Ê∑±Â∫¶‰ºòÂÖàÊêúÁ¥¢ ‰∫åÂèâÊ†ë üëç 1997 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return root
        if root == p or root == q:
            return root
        l = self.lowestCommonAncestor(root.left, p, q)
        r = self.lowestCommonAncestor(root.right, p, q)
        if l and r:
            return root
        if l:
            return l
        return r
        
# leetcode submit region end(Prohibit modification and deletion)


```

#### 253 Meeting Rooms II

```python
# Given an array of meeting time intervals intervals where intervals[i] = [
# starti, endi], return the minimum number of conference rooms required. 
# 
#  
#  Example 1: 
#  Input: intervals = [[0,30],[5,10],[15,20]]
# Output: 2
#  
#  Example 2: 
#  Input: intervals = [[7,10],[2,4]]
# Output: 1
#  
#  
#  Constraints: 
# 
#  
#  1 <= intervals.length <= 10‚Å¥ 
#  0 <= starti < endi <= 10‚Å∂ 
#  
# 
#  Related Topics Ë¥™ÂøÉ Êï∞ÁªÑ ÂèåÊåáÈíà ÂâçÁºÄÂíå ÊéíÂ∫è Â†ÜÔºà‰ºòÂÖàÈòüÂàóÔºâ üëç 479 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def minMeetingRooms(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: int
        intervals = [[0,30],[5,10],[15,20]]
        Á¨¨‰∏Ä‰∏™‰∫∫‰ªé0‰∏äËΩ¶Ôºå‰ªé30‰∏ãËΩ¶Ôºõ
        Á¨¨‰∫å‰∏™‰∫∫‰ªé5‰∏äËΩ¶Ôºå10‰∏ãËΩ¶„ÄÇ„ÄÇ„ÄÇ
        ‰∫∫Êï∞ 1    2     1     2     1      0
             0----5----10----15----20-----30
        ÂèòÂåñ +1   +1    -1    +1    -1    -1
        """
        res = []
        for x, y in intervals:
            res.append([x, 1])
            res.append([y, -1])
        max_cnt = 0
        cnt = 0
        res.sort(key = lambda x:x[0])
        # [[1,1],[13,1],[13,-1],[15,-1]]
        pre_time = res[0][0]
        for time, mark in res:
            if time != pre_time:
                max_cnt = max(max_cnt, cnt)
                pre_time = time
            cnt += mark
        max_cnt = max(max_cnt, cnt)
        return max_cnt




# leetcode submit region end(Prohibit modification and deletion)

```


#### 621. Task Scheduler

```python
# Given a characters array tasks, representing the tasks a CPU needs to do, 
# where each letter represents a different task. Tasks could be done in any order. 
# Each task is done in one unit of time. For each unit of time, the CPU could 
# complete either one task or just be idle. 
# 
#  However, there is a non-negative integer n that represents the cooldown 
# period between two same tasks (the same letter in the array), that is that there 
# must be at least n units of time between any two same tasks. 
# 
#  Return the least number of units of times that the CPU will take to finish 
# all the given tasks. 
# 
#  
#  Example 1: 
# 
#  
# Input: tasks = ["A","A","A","B","B","B"], n = 2
# Output: 8
# Explanation: 
# A -> B -> idle -> A -> B -> idle -> A -> B
# There is at least 2 units of time between any two same tasks.
#  
# 
#  Example 2: 
# 
#  
# Input: tasks = ["A","A","A","B","B","B"], n = 0
# Output: 6
# Explanation: On this case any permutation of size 6 would work since n = 0.
# ["A","A","A","B","B","B"]
# ["A","B","A","B","A","B"]
# ["B","B","B","A","A","A"]
# ...
# And so on.
#  
# 
#  Example 3: 
# 
#  
# Input: tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
# Output: 16
# Explanation: 
# One possible solution is
# A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle ->
#  idle -> A
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= task.length <= 10‚Å¥ 
#  tasks[i] is upper-case English letter. 
#  The integer n is in the range [0, 100]. 
#  
# 
#  Related Topics Ë¥™ÂøÉ Êï∞ÁªÑ ÂìàÂ∏åË°® ËÆ°Êï∞ ÊéíÂ∫è Â†ÜÔºà‰ºòÂÖàÈòüÂàóÔºâ üëç 1032 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def leastInterval(self, tasks, n):
        """
        :type tasks: List[str]
        :type n: int
        :rtype: int
        """
        from collections import defaultdict
        wc = defaultdict(int)
        mc = 0
        for t in tasks:
            wc[t] += 1
            if wc[t] > mc:
                mc = wc[t]

        mcc = 0
        for k, c in wc.items():
            if c == mc:
                mcc += 1

        return max(len(tasks), (mc - 1) * (n + 1) + mcc)

# leetcode submit region end(Prohibit modification and deletion)

```


#### 91. Decode Ways

```python
# A message containing letters from A-Z can be encoded into numbers using the 
# following mapping: 
# 
#  
# 'A' -> "1"
# 'B' -> "2"
# ...
# 'Z' -> "26"
#  
# 
#  To decode an encoded message, all the digits must be grouped then mapped 
# back into letters using the reverse of the mapping above (there may be multiple 
# ways). For example, "11106" can be mapped into: 
# 
#  
#  "AAJF" with the grouping (1 1 10 6) 
#  "KJF" with the grouping (11 10 6) 
#  
# 
#  Note that the grouping (1 11 06) is invalid because "06" cannot be mapped 
# into 'F' since "6" is different from "06". 
# 
#  Given a string s containing only digits, return the number of ways to decode 
# it. 
# 
#  The test cases are generated so that the answer fits in a 32-bit integer. 
# 
#  
#  Example 1: 
# 
#  
# Input: s = "12"
# Output: 2
# Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).
#  
# 
#  Example 2: 
# 
#  
# Input: s = "226"
# Output: 3
# Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2
#  6).
#  
# 
#  Example 3: 
# 
#  
# Input: s = "06"
# Output: 0
# Explanation: "06" cannot be mapped to "F" because of the leading zero ("6" is 
# different from "06").
#  
# 
#  
#  Constraints: 
# 
#  
#  1 <= s.length <= 100 
#  s contains only digits and may contain leading zero(s). 
#  
# 
#  Related Topics Â≠óÁ¨¶‰∏≤ Âä®ÊÄÅËßÑÂàí üëç 1274 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int

        12322
        11106
        """
        n = len(s)
        if s[0] == '0':
            return 0
        if n == 1:
            return 1
        pre1 = 1
        if s[1] == '0':
            if '1' <= s[0] <= '2':
                pre2 = 1
            else:
                return 0
        else:
            if "11" <= s[:2] <= "26":
                pre2 = 2
            else:
                pre2 = 1

        for i in range(2, n):
            if s[i] == '0':
                if s[i-1] == '0' or s[i-1] > '2':
                    return 0
                pre1, pre2 = pre2, pre1
            else:
                if "11" <= s[i-1:i+1] <= "26":
                    pre1, pre2 = pre2, pre1 + pre2
                else:
                    pre1, pre2 = pre2, pre2
        return pre2




# leetcode submit region end(Prohibit modification and deletion)


```

#### 88. Merge Sorted Array

```python
# You are given two integer arrays nums1 and nums2, sorted in non-decreasing 
# order, and two integers m and n, representing the number of elements in nums1 and 
# nums2 respectively. 
# 
#  Merge nums1 and nums2 into a single array sorted in non-decreasing order. 
# 
#  The final sorted array should not be returned by the function, but instead 
# be stored inside the array nums1. To accommodate this, nums1 has a length of m + 
# n, where the first m elements denote the elements that should be merged, and the 
# last n elements are set to 0 and should be ignored. nums2 has a length of n. 
# 
#  
#  Example 1: 
# 
#  
# Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
# Output: [1,2,2,3,5,6]
# Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
# The result of the merge is [1,2,2,3,5,6] with the underlined elements coming 
# from nums1.
#  
# 
#  Example 2: 
# 
#  
# Input: nums1 = [1], m = 1, nums2 = [], n = 0
# Output: [1]
# Explanation: The arrays we are merging are [1] and [].
# The result of the merge is [1].
#  
# 
#  Example 3: 
# 
#  
# Input: nums1 = [0], m = 0, nums2 = [1], n = 1
# Output: [1]
# Explanation: The arrays we are merging are [] and [1].
# The result of the merge is [1].
# Note that because m = 0, there are no elements in nums1. The 0 is only there 
# to ensure the merge result can fit in nums1.
#  
# 
#  
#  Constraints: 
# 
#  
#  nums1.length == m + n 
#  nums2.length == n 
#  0 <= m, n <= 200 
#  1 <= m + n <= 200 
#  -10‚Åπ <= nums1[i], nums2[j] <= 10‚Åπ 
#  
# 
#  
#  Follow up: Can you come up with an algorithm that runs in O(m + n) time? 
# 
#  Related Topics Êï∞ÁªÑ ÂèåÊåáÈíà ÊéíÂ∫è üëç 1598 üëé 0


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: None Do not return anything, modify nums1 in-place instead.
        """

        k1, k2 = 0, 0
        for i in range(m-1, -1, -1):
            nums1[i+n] = nums1[i]

        i = 0
        while k1 < m and k2 < n:
            if nums1[k1+n] == nums2[k2]:
                nums1[i] = nums1[k1+n]
                i += 1
                nums1[i] = nums2[k2]
                i += 1
                k1 += 1
                k2 += 1
            elif nums1[k1+n] > nums2[k2]:
                nums1[i] = nums2[k2]
                k2 += 1
                i += 1
            else:
                nums1[i] = nums1[k1+n]
                k1 += 1
                i += 1

        while k1 < m:
            nums1[i] = nums1[k1+n]
            i += 1
            k1 += 1
        while k2 < n:
            nums1[i] = nums2[k2]
            i += 1
            k2 += 1


s = Solution()
a = [1,2,3,0,0,0]
m =			3
b =			[2,5,6]
n =			3
print(s.merge(a, m, b, n))
# leetcode submit region end(Prohibit modification and deletion)


```

#### todolist [76, 269, 139, 523, 23, 200, 283, 65, 211, 347, 34, 721, 42, 339, 2, 987, 636, 121, 146, 162, 282, 17, 986, 43, 140]





>>>>>>> a6458e09e981973146b15bab82b079e0ee0762ad
# ÂÖ∂‰ªñ


#### 560 Â≠êÊï∞ÁªÑÂíå‰∏∫kÁöÑ‰∏™Êï∞

```python
class Solution(object):
    def subarraySum(self, nums, k):
        """Â≠êÊï∞ÁªÑÂíå‰∏∫kÁöÑ‰∏™Êï∞
        :type nums: List[int]
        :type k: int
        :rtype: int
        Example:
            #  Input: nums = [1,1,1], k = 2
            # Output: 2
        Solution:
            ÂâçÁºÄÂíå+ÂìàÂ∏å
        """
        from collections import defaultdict
        # [1,1,1]
        # 1
        # cur_sum=3
        # pre_sum_cnt=[1:1, 2:1]
        # diff = 3-2=1
        # pre_sum = 1
        # cur_sum - pre_sum = k
        # pre_sum = cur_sum - k
        pre_sum_cnt = defaultdict(int)
        pre_sum_cnt[0] = 1
        pre_sum = 0
        cnt = 0
        for num in nums:
            cur_sum = pre_sum + num
            diff = cur_sum - k
            cnt += pre_sum_cnt[diff]
            pre_sum_cnt[cur_sum] += 1
            pre_sum = cur_sum
        return cnt

```


#### 791 Â∞Üs‰∏≠ÁöÑÂ≠óÊØçÊåâorderÁöÑÈ°∫Â∫èËøõË°åÊéíÂ∫è

```python
class Solution(object):
    def customSortString(self, order, s):
        """Â∞Üs‰∏≠ÁöÑÂ≠óÊØçÊåâorderÁöÑÈ°∫Â∫èËøõË°åÊéíÂ∫è
        Èù¢ÁªèÂú∞ÂùÄÔºöhttps://www.1point3acres.com/bbs/thread-650769-1-1.html
        :type order: str
        :type s: str
        :rtype: str
        Example:
            # Input: order = "cba", s = "abcd"
            # Output: "cbad"

            # Input: order = "cba", s = "abad"
            # Output: "baad" (Ë¶ÅÊ≥®ÊÑès‰∏≠Â≠óÁ¨¶ÈáçÂ§çÁöÑÈóÆÈ¢ò)

        Solution:
            hashË°®
        """
        from collections import defaultdict
        letter_cnt = defaultdict(int)
        for letter in s:
            letter_cnt[letter] += 1
        order_letter_set = set()
        for letter in order:
            order_letter_set.add(letter)

        res = []
        for letter in order:
            if letter in letter_cnt:
                while letter_cnt[letter] > 0:
                    res.append(letter)
                    letter_cnt[letter] -= 1

        for letter in s:
            if letter not in order_letter_set:
                res.append(letter)

        return ''.join(res)

```


## ÂÖ∂‰ªñËµÑÊñô

1. https://leetcode.com/problem-list/top-facebook-questions/
2. https://leetcode.cn/company/facebook/problemset/
3. https://www.glassdoor.sg/Interview/Meta-Machine-Learning-Engineer-Interview-Questions-EI_IE40772.0,4_KO5,30.htm
4. ËÆ∞ÂΩïÊàëÊõæÁªèÈù¢ËØï FacebookÔºàMetaÔºâ ÁöÑÁªèÂéÜÔºöhttps://sichengingermay.com/facebook-interview/
5. MetaÈù¢ËØïÁªèÂéÜÔºåË¢´ÊãíÔºå‰∏§Ê¨°ÔºÅhttps://zhuanlan.zhihu.com/p/499547331




##


```

"""
You are given an array of integers. Write an algorithm that brings all nonzero elements to the left of the array, and returns the number of nonzero elements. The algorithm should operate in place, i.e. shouldn't create a new array. The order of the nonzero elements does not matter. The numbers that remain in the right portion of the array can be anything. Example: given the array [ 1, 0, 2, 0, 0, 3, 4 ], a possible answer is [ 4, 1, 3, 2, ?, ?, ? ], 4 non-zero elements, where "?" can be any number. Code should have good complexity and minimize the number of writes to the array.


input:


           l=0
                    r=0
[ 1, 2, 3, 4, 0, 0, 0 ]


[]


return:[1, 2, 3, 4, 0,0,0]
[1,2,3,4]

solution:

time: O(n)
space: O(1)



"""

def move_zeroes(nums: List[int]) -> int:
    """
    l
    r
    [1,2,0]
    l=2
    r=2
    n=3
    nums[r]=2 != 0

    nums[l], nums[r]
    """
    # l: means the no-zero index
    # r: cur position
    l, r = 0, 0
    n = len(nums)
    while r < n:
        if nums[r] != 0:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
        r += 1
    return l


"""
Given a 2D board and a list of words, return all words in the board that could be found from sequentially adjacent cells. Each word can start with any position in the board and can go horizontally or vertically.

List of words: ["face", "book", "good", "bug", "oooo....o"]

[
"bkdu", 
"goob", 
"face"
]



b
g

"bgbg"

"googoogoog"

["face", "book", "good"]

1.
2. words
3. 


[
"bkdu", 
"goob", 
"face"
]

check face


face

bfs dfs


2d board: k1 * k2
list of words:n
max_length: m

time: n * m

"""


def search(word, cur_index, x, y, board):
    """search word[cur_index:] in board, and we now at positon (x, y)""""
    m, n = len(board), len(board[0])
    if x < 0 or x >= m or y < 0 or y >= n:
        return False
    if cur_index >= len(word):
        return True
    if word[cur_index] != board[x][y]:
        return False
    for dx, dy in [[1, 0], [-1, 0], [0, 1], [0, -1]]:
        if search(word, cur_index + 1, x + dx, y + dy, board):
            return True
    return False

def find_words_in_2d_board(words, board):
    if not board:
        return []
    m, n = len(board), len(board[0])
    res = []
    for word in words:
        find_word_flag = False
        for x in range(m):
            for y in range(n):
                if search(word, 0, x, y, board):
                    find_word_flag = True
                    break
        if find_word_flag:
            res.append(word)
    return res


"""
words: ['a', 'a?', 'g*od', '']
board:

[
"bkdu", 
"goob", 
"face"
]

"""


```